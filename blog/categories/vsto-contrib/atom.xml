<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vsto-contrib | Jake Ginnivan's blog]]></title>
  <link href="http://JakeGinnivan.github.io/blog/categories/vsto-contrib/atom.xml" rel="self"/>
  <link href="http://JakeGinnivan.github.io/"/>
  <updated>2014-01-05T16:26:22+00:00</updated>
  <id>http://JakeGinnivan.github.io/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VSTO Contrib v0.12 Released]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-contrib/v0-12-released/"/>
    <updated>2013-08-06T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-contrib/v0-12-released</id>
    <content type="html"><![CDATA[<p>I have just pushed the button on VSTO Contrib v0.12!</p>

<p>This release is aimed at fixing a bunch of bugs, like some callbacks not working, creating a viewmodel instance for when no documents are open and supporting Office 2013!
Due to the complexities of supporting multiple versions, I have dropped Office 2007 support. Please let me know if this is a major issue, and I might try to add it back in next release.</p>

<p>I have also released a getting started video. This is one of the first screencasts I have done, so I will likely do it again next release. Also when you install VSTO Contrib, a readme will popup, this will help you get started.</p>

<object width="420" height="315"><param name="movie" value="//www.youtube.com/v/TxRjNsaVX6U?version=3&amp;hl=en_GB"></param><param name="allowFullScreen" value="true"></param><param name="allowscriptaccess" value="always"></param><embed src="http://JakeGinnivan.github.io//www.youtube.com/v/TxRjNsaVX6U?version=3&amp;hl=en_GB" type="application/x-shockwave-flash" width="420" height="315" allowscriptaccess="always" allowfullscreen="true"></embed></object>


<p>I will try to produce some documentation/blog posts on VSTO Contrib over the next few weeks.</p>

<p>From now, I will be tracking changes/fixes a lot better. Please report any issues at <a href="https://github.com/JakeGinnivan/VSTOContrib/issues">https://github.com/JakeGinnivan/VSTOContrib/issues</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VSTOContrib Context Menus]]></title>
    <link href="http://JakeGinnivan.github.io/vstocontrib-outlook-contextmenus/"/>
    <updated>2012-08-22T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vstocontrib-outlook-contextmenus</id>
    <content type="html"><![CDATA[<p>So the scenario was that I want to show additional menu items when right clicking on an email.</p>

<!-- more -->


<pre><code>&lt;contextMenus&gt;
  &lt;contextMenu idMso="ContextMenuMailItem"&gt;
    &lt;button id="MyContextMenuMailItem"
            label="Perform the action..."
            onAction="EmailItems"
            imageMso="Forward"/&gt;
  &lt;/contextMenu&gt;
  &lt;contextMenu idMso="ContextMenuMultipleItems"&gt;
    &lt;button id="MyContextMenuMultipleItems"
        label="Perform the action on multiple items..."
        onAction="EmailItems"
        imageMso="Forward"/&gt;
  &lt;/contextMenu&gt;
&lt;/contextMenus&gt;
</code></pre>

<p>In the current release, the EmailItems callback would never be called. This is because of the way Outlook handles selections and context menus. VSTOContrib now correctly routes the callbacks to the correct viewmodel.</p>

<p>Now you can simply add the callback to your viewmodel like this:</p>

<pre><code>[OutlookRibbonViewModel(OutlookRibbonType.OutlookExplorer)]
public class ExplorerViewModel : OfficeViewModelBase, IRibbonViewModel
{
    Folder context;
    Explorer explorer;

    public IRibbonUI RibbonUi { get; set; }
    public void Initialised(object context)
    {
        this.context = (Folder) context;
    }

    public void EmailItems(IRibbonControl control)
    {
        if (explorer.Selection.Count == 1)
        {
            var title = ((MailItem) explorer.Selection[1]).Subject;
        }
    }

    public void CurrentViewChanged(object currentView)
    {
        explorer = (Explorer) currentView;
    }

    public void Cleanup()
    {
    }
}
</code></pre>

<p>And you will get the EmailItems callback as you would expect. I also recommend putting a getVisible callback to hide the menu item if the selection does not contain mail items for instance.</p>

<p>Hope this helps someone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VSTO Contrib RibbonFactory]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-contrib/ribbon-factory/"/>
    <updated>2011-04-05T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-contrib/ribbon-factory</id>
    <content type="html"><![CDATA[<h1>Why?</h1>

<p>When I started creating a RibbonFactory, I hadn&rsquo;t actually looked into the way VSTO does it, I just wanted to use Ribbon XML, because it has more flexibility, but have a single class to represent a single ribbon and also support an IoC container, and DI for my ribbons.</p>

<p>Once I got that working, I started tweaking, improving, adding in context awareness and a view other things. Recently my reasons for trying to finish this have been:</p>

<ul>
<li>Lack of IoC/DI support in VSTO</li>
<li>Cost of brute force reflection when using ribbon designer</li>
<li>Wanting to use Ribbon XML over Ribbon Designer, but not really viable due to missing context for ribbon xml.</li>
<li>Ribbon XML having a single callback file</li>
<li>Making custom task panes, which are associated with a ribbon (i.e. button to show/hide custom task pane) really simple.</li>
</ul>


<p>The VSTO tooling is pretty good, especially around the designer, but I want the best of both worlds, and to be able to fall into <code>the pit of success</code> as <a href="http://www.paulstovell.com/">Paul Stovell</a> often says.</p>

<!-- more -->


<h1>View Model&rsquo;s in Office?</h1>

<p>I have broken all the differences between each of the Office applications up into terminology which is common to all of them, and abstracted the behaviours of each. The way I have broken it down is into</p>

<p><code>View</code> &ndash; This is the Outlook Explorer, Word Window, Appointment Inspector. Whatever the actual window is that is displaying something in office, this is the view.
<code>Context</code> &ndash; This is what the window is displaying, in word the Window is displaying a document, in PowerPoint that is a Presentation, in Outlook it is the Contact, or Appointment.
<code>ViewModel</code> &ndash; Your entry point into VSTO now is view models. You define a few model for a particular ribbon type, then whenever a new context is created which has that ribbon type, you get a new view model instance, with the context set. You will also be notified when the current active view changes (switching between two windows showing the same document).</p>

<h1>Show us the code</h1>

<p>You start off with the IRibbonViewModel interface which looks like:</p>

<pre><code>public interface IRibbonViewModel
{
    IRibbonUI RibbonUi { get; set; }
    void Initialised(object context);
    void CurrentViewChanged(object currentView);
    void Cleanup();
}
</code></pre>

<p><code>RibbonUi</code> will be set for you, this allows you to invalidate ribbon controls and activate different tabs on the ribbon.
<code>Initialised(object context)</code> will be called when the context is available, allowing you to hook into events, populate viewmodel data or anything you want. <code>CurrentViewChanged</code> and <code>Cleanup</code> are called when the current active window changes, or the context is closing respectively.</p>

<p>To get started all you have to do is create a class and make it inherit from IRibbonViewModel, then decorate it with the <code>RibbonViewModelAttribute</code>, which will look like this:</p>

<pre><code>[RibbonViewModel(OutlookRibbonType.OutlookContact)]
public class ContactFeed : OfficeViewModelBase, IRibbonViewModel, IRegisterCustomTaskPane
{

}
</code></pre>

<p>OfficeViewModelBase is a helper base class which inherits from INotifyPropertyChanged, and has helpers for raising property changed events with compile time safety.</p>

<p>The IRegisterCustomerTaskPane is the next interesting interface you have access to.</p>

<pre><code>public interface IRegisterCustomTaskPane
{
    void RegisterTaskPanes(Register register);
}

public delegate ICustomTaskPaneWrapper Register(Func&lt;UserControl&gt; controlFactory, string title);
</code></pre>

<p>An example implementation is:</p>

<pre><code>public void RegisterTaskPanes(Register register)
{
    _twitterTaskPane = register(() =&gt; new WpfPanelHost{Child = new TwitterFeed{DataContext = this}}, "Twitter");
    _twitterTaskPane.Visible = true;
    PanelShown = true;
    _twitterTaskPane.VisibleChanged += TwitterTaskPaneVisibleChanged;
    TwitterTaskPaneVisibleChanged(this, EventArgs.Empty);
}
</code></pre>

<p>Now the RibbonFactory will take care of registering the custom task pane when new views are opened, and keep properties synchronised across the same task panes on different views (visibility etc).</p>

<h1>How does it work?</h1>

<p>This was the hard part, it all sounds good in theory, but getting all the pieces together was a lot of hard work.</p>

<p>When <code>GetCustomIU(string RibbonId)</code> is called, the RibbonFactory finds a registered ViewModel for that ribbon type, it then fines the appropriate RibbonXml resource through the current <code>IViewLocator</code>, so you can specify your own conventions, by default it will look for a Resource with the same name, or try to match without view/viewmodel appended to the end of the names.</p>

<p>Once the RibbonXML has been found, the RibbonFactory rewrites all callbacks and caches them inside the <code>ViewModelResolver</code> class, it also generates a tag and inserts that into the control.</p>

<p><strong>Before:</strong><br/>
<code>&lt;toggleButton id="testTogglePanelButton" onAction="PanelShown" getPressed="PanelShown" label="Show Panel" showImage="false" /&gt;</code><br/>
<strong>After:</strong><br/>
<code>&lt;toggleButton id="testTogglePanelButton" onAction="PressedOnAction" getPressed="GetPressed" label="Show Panel" showImage="false" tag="RibbonType1testTogglePanelButton" /&gt;</code></p>

<p>The RibbonFactory has all known callback signatures defined, so when Office invokes one of the callbacks, it invoke a method on the RibbonFactory.<br/>
RibbonXml callbacks have the control that initiated the callback available, and the control has the associated context, so the RibbonFactory will grab the context, then ask the <code>ViewModelResolver</code> to locate the current active view for that context. It then uses the Tag to know what the original callback was, and it will invoke that callback for you.</p>

<p>Because it handles all the callbacks manually, it has no problems calling a Property getter or setter instead of a method. It also has quite nice error reporting when the viewmodel has the wrong method signature etc, unlike VSTO.</p>

<h1>Setup/Getting Started</h1>

<p>Getting started using the Ribbon Factory is quite easy, in your ThisAddIn.cs you have to override the <code>IRibbonExtensibility CreateRibbonExtensibilityObject()</code> and create a instance of the RibbonFactory for your office application. i.e OutlookRibbonFactory, WordRibbonFactory etc.</p>

<p>Then in the Internal Startup method you need to add the bootstrapping and initialisation code. The TwitterFeed demo project I have looks like this:</p>

<pre><code>public partial class ThisAddIn
{
    private AddinBootstrapper _core;

    private static void ThisAddInStartup(object sender, EventArgs e)
    {
        //WPF Support
        if (System.Windows.Application.Current == null)
            new Application { ShutdownMode = ShutdownMode.OnExplicitShutdown };
    }

    protected override IRibbonExtensibility CreateRibbonExtensibilityObject()
    {
        return new OutlookRibbonFactory(typeof(AddinBootstrapper).Assembly);
    }

    private void ThisAddInShutdown(object sender, EventArgs e)
    {
        _core.Dispose();
        System.Windows.Application.Current.Shutdown();
    }

    private void InternalStartup()
    {
        _core = new AddinBootstrapper();
        OutlookRibbonFactory.SetApplication(Application);
        RibbonFactory.Current.InitialiseFactory(
            t =&gt; (IRibbonViewModel)_core.Resolve(t),
            CustomTaskPanes);

        Startup += ThisAddInStartup;
        Shutdown += ThisAddInShutdown;
    }
}
</code></pre>

<h1>Summary</h1>

<p>The Ribbon Factory in VSTO Contrib I think is quite awesome, it gives a heap of features and makes VSTO development far easier. And it really complements the work the VSTO team has done around custom task panes. I will be exposing more VSTO related stuff as time goes by.</p>

<p>Now go grab the bits from <a href="http://vstocontrib.codeplex.com/releases">http://vstocontrib.codeplex.com/releases</a> (very soon, for now source =))</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to VSTO Contrib]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-contrib/introduction/"/>
    <updated>2011-04-05T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-contrib/introduction</id>
    <content type="html"><![CDATA[<h1>Goal of VSTO Contrib</h1>

<p>When I first started on this library, it was a very simple set of classes designed to help me do trivial tasks in VSTO, such as simplifying listening to certain events, wrappers, and it was really a dumping ground for code that solved problems I had while developing VSTO solutions.</p>

<p>Just before TechEd last year (August), I started trying to tackle some more fundamental architectural issues, such as no ability to use DI, or IoC, which often causes VSTO solutions to have Ribbons with hundreds of lines of code behind, this issue is made worse with Ribbon XML which only lets you have a single callback file for ALL ribbons.</p>

<!-- more -->


<h1>Version Support</h1>

<p>I am targeting both Office 2007 &amp; 2010 using either .NET 3.5 or .NET 4.0, and currently support Outlook, Word, Excel and PowerPoint. This means there are 16 different packages you can download.</p>

<h1>Features</h1>

<h2>Ribbon Factory</h2>

<p>The Ribbon Factory, apart from needed a better name, is the most compelling feature of VSTO Contrib.</p>

<p>It is a ribbon factory, similar to the one VSTO uses to bring the Ribbon Designer to life (<a href="../vsto-ribbon-designer-in-depth">read more</a>), except mine targets Ribbon XML, and brings all the nice features that the ribbon designer has, like the current context (Contact, Word Document, Powerpoint presentation etc) plus a whole lot more like:</p>

<ul>
<li><p>Creates a new instance of a &lsquo;ViewModel&rsquo; class you define for each context (document etc), and will notify you when the current view changes (multiple windows displaying same document). This view model is managed, and will be cleaned up when the context is closed.</p></li>
<li><p>ViewModels are for a single, or multiple Ribbon types, Word/Excel/PowerPoint are simply the Document, Workbook and Presentation ribbons, but outlook you can create a view model for an AppointmentItems, another viewmodel for ContactItem&rsquo;s, another view model for MailItems</p></li>
<li><p>IoC container support, currently takes a Func&lt;Type, IRibbonViewModel> during initialisation to support custom resolution. I will be creating a IRibbonViewModelFactory at a later stage.</p></li>
<li><p>Synchronised TaskPanes, one of the most common questions on StackOverflow is how do I wire up a button on the ribbon to my custom task pane. It is actually quite hard out of the box, with VSTO Contrib, just inherit from IRegisterCustomTaskPane on your ViewModel and the Ribbon Factory will manage the registration of custom task panes on new windows, and a few other things.</p></li>
<li><p>WPF like binding support, RibbonXML requires you to know the method syntax of all callbacks. You can now go <toggleButton onAction="PanelShown" getPressed="PanelShown" /> where PanelShown is a <strong>property</strong>, it will even listen to PropertyChanged events and invalidate the ribbon control!</p></li>
</ul>


<p>I won&rsquo;t go into detail about how the Ribbon Factory works, and what the code looks like here. But if you would like to read more, I will write all about it at <a href="ribbon-factory">the ribbon factory</a></p>

<h2>Code Driven Click-Once updates</h2>

<p>Due to a different security model, and VSTO having a custom ClickOnce installer if you try and get the Deployment information, then call ApplicationDeployment.Update you can find yourself with a broken add-in.</p>

<p>VSTO Contrib has a helper class to make updating your add-in super easy. Under the covers it is finding the location of the VSTOInstaller.exe, first through registry, then falling back to file system. It then sets up the application trusts needed to make the update process work nicely.</p>

<pre><code>new VstoClickOnceUpdater()
            .CheckForUpdateAsync(
                r =&gt;
                {
                    if (r.Updated)
                    {
                        MessageBox.Show("My awesome add-in was updated");
                    }
                });
</code></pre>

<h2>WPF Integration</h2>

<p>VSTO Contrib has a few helper classes to make WPF development inside VSTO much easier.</p>

<p>Firstly it has a WpfPanelHost, which is registered correctly for COM interop, and works around some issues where WPF controls would not draw correctly until the window is moved.</p>

<p>It also provides a OfficeViewModelBase, and DelegateCommand class to enable easy data binding to your Ribbon View Model.</p>

<h2>COM interop helpers</h2>

<p>One of the things I found really hard when starting VSTO development was learning about the COM interop side of things, and in particularly the &lsquo;right&rsquo; way of doing it, which is why I wrote the blog post on <a href="vsto-com-interop">vsto-com-interop</a>, which explains how the whole COM Interop thing works, any why you should be calling Marshal.ReleaseComObject.</p>

<p>The issue is that code quickly becomes ugly and unmanageable when everything is wrapped in try{} finally{Marshal.ReleaseComObject();}. It also is not tollerant to later versions of Office, which may swap out some of these unmanaged com objects, for managed .net objects. If they do that you will find the call to Marshal.ReleaseComObject throws an exception.</p>

<p>These helpers come in two flavours, simple, and dynamic proxies.</p>

<h3>.WithComCleanup()</h3>

<p>This extension method will return either a <code>Wrapped&lt;ComType&gt; : IDisposable</code> (simple) or a <code>IComType : ComType, IDisposable</code> (dynamic proxy).</p>

<p>Usage is:
<code>using (var sheets = workbook.WorkSheets.WithComCleanup())</code>
<code>sheets.Resource.Add() //for simple</code>
or <code>sheets.Add() //for dynamic proxy version</code></p>

<p>The dynamic proxy is slightly nicer, but you have to take on a dependency to Castle.Core if you want that. If you want to see some more code examples of how this can cleanup your VSTO/Office Automation code, <a href="com-cleanup-extension-methods">have a look here</a></p>

<p>The dynamic proxy version simply removes the need to go .Resource to access the wrapped COM object.</p>

<h3>.ComLinq<T>()</h3>

<p>Allows you to cleanly write linq against office collections. <em>Beware</em> as this will return a IEnumerable<T> with a custom Enumerator which releases the previous item when MoveNext is called. This means it is perfect for code like this:</p>

<pre><code>using (var someSheet = workbook.Sheets.ComLinq&lt;WorkSheet&gt;().Where(s=&gt;s.Name == "Sheet1"))
{ someSheet.Name = "NewSheetName"; }
</code></pre>

<p>But you will get a RCW has been separated from underlying com object exception if you do this:</p>

<pre><code>var sheetOne = workbook.Sheets.ComLinq&lt;WorkSheet&gt;().SingleOrDefault(s=&gt;s.Name == "Sheet1");
sheetOne.Name = "NewSheetName"; //Will throw exception, because Enumerator has already released the WorkSheet as SingleOrDefault forces the IEnumerable to be iterated.
</code></pre>

<p>Future versions may have a custom collection which only expose specific operations to make this extension method more predictable. For the moment, use with caution.</p>

<h3>Outlook User Properties helpers</h3>

<p>You will find some handy extensions called GetPropertyValue<T>, and SetPropertyValue<T>, which are handy wrappers around the UserProperties collection on most outlook items. Has options to automatically create the properties, and specify if they are folder level so they are accessible through search etc. Very handy!</p>

<h2>FolderHomePage [Outlook Only]</h2>

<p>Greatly simplifies the process of creating a custom view for a folder. Ever wanted to select a folder in Outlook, and have a fully blown WPF custom view be displayed, well, this class is for you.</p>

<p>Note: Does need outlook to be running as Administrator, as it registers types for com interop and registers the user controls as safe for scripting, which requires the process to be elevated. I may end up making this an extension which will shell out to a elevated process.</p>

<h2>OutlookFolderMonitor</h2>

<p>Quite a simple class which will monitor an Outlook MAPIFolder for changes, this includes Add/Modified and deleting. Each event has the item being affected, delete is not trivial, which makes this class particularly handy.</p>

<h2>GenericSynchronisationService</h2>

<p>As the name implies, this is a synchronisation helper, which takes care of synchronisation logic, all you have to do is create a source and remote provider. It greatly simplifies your job if you need to synchronise contacts or appointments etc with outlook.</p>

<h1>Where can I get it</h1>

<p>I will be releasing it before MIX 2011 at <a href="http://vstocontrib.codeplex.com/releases">http://vstocontrib.codeplex.com/releases</a></p>

<h1>Feedback</h1>

<p>I would love feedback, I still have a lot of unit testing to do and test every combination of .net and office. Please if you have an issue, let me know!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cleaning Up Office COM Interop Code With Extension Methods]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-contrib/com-cleanup-extension-methods/"/>
    <updated>2011-04-05T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-contrib/com-cleanup-extension-methods</id>
    <content type="html"><![CDATA[<p>Office Automation and COM interop code can be really ugly, this post show you how the extension methods in VSTO Contrib can help</p>

<!-- more -->


<h1>Ugly Office Automation Code</h1>

<p>You have been tasked with the simple job of writing a console application which goes through every contact in an Outlook addressbook and replacing Smith, John with John Smith. Because you want Outlook 2003 to close properly when you call quit, you make sure you manage your references properly. The code you come up with looks something like:</p>

<pre><code>_Application app;
_NameSpace session;
_MAPIFolder folder;
Items contactItems;
try
{
    app = new Application();
    session = app.Session;
    folder = session.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
    contactItems = folder.Items;
    foreach (_ContactItem contactItem in folder.Items)
    {
        try
        {
            if (!string.IsNullOrEmpty(contactItem.FullName))
            {
                contactItem.FileAs = contactItem.FullName;
                contactItem.Save();
            }
        }
        finally
        {
            if (Marshal.IsComObject(contactItem))
                Marshal.ReleaseComObject(contactItem);
        }
    }
}
finally
{
    if (contactItems != null &amp;&amp; Marshal.IsComObject(contactItems))
        Marshal.ReleaseComObject(contactItems);
    if (folder != null &amp;&amp; Marshal.IsComObject(folder))
        Marshal.ReleaseComObject(folder);
    if (session != null &amp;&amp; Marshal.IsComObject(session))
        Marshal.ReleaseComObject(session);

    if (app != null)
    {
        app.Quit();
        if (Marshal.IsComObject(app))
            Marshal.ReleaseComObject(app);
    }
}
</code></pre>

<p>The above code and way too much code to easily scan and see what is going on.</p>

<h2>Better code</h2>

<p>So what does it look like using the simple helpers:</p>

<pre><code>using (var app = new Application().WithComCleanup())
{
    using (var session = app.Resource.Session.WithComCleanup())
    {
        var folder = session.Resource.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
        using (var contactsFolder = folder.Resource.WithComCleanup())
        {
            foreach (var contactItem in contactsFolder.Resource.Items.ComLinq&lt;_ContactItem&gt;())
            {
                if (!string.IsNullOrEmpty(contactItem.FullName))
                {
                    contactItem.FileAs = contactItem.FullName;
                    //contactItem.Save();
                }
            }
        }
    }
    app.Quit();
}
</code></pre>

<h1>Introducing Dynamic Proxies</h1>

<p>The reason we can&rsquo;t do this, is the COM land doesn&rsquo;t understand IDisposable. So VSTO Contrib has a generated set of interfaces that look like this:</p>

<pre><code>public interface IApplication : Microsoft.Office.Interop.Outlook.Application, IDisposable { }
</code></pre>

<p>The .WithComCleanup actually is also generated, so it looks like this:</p>

<pre><code>public static IApplication WithComCleanup(this Outlook.Application resource)
{  return resource.WithComCleanup&lt;Outlook.Application, IApplication&gt;(); }
</code></pre>

<p>The generic version will generate a proxy on the fly, and will call Marshal.ReleaseComObject on the proxied resource when Dispose is called. The end result is we now no longer have .Resource scattered all through our code, which again improves readability.</p>

<pre><code>using (var app = new Application().WithComCleanup())
{
    using (var session = app.Session.WithComCleanup())
    {
        var folder = session.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
        using (var contactsFolder = folder.WithComCleanup())
        {
            foreach (var contactItem in contactsFolder.Items.ComLinq&lt;_ContactItem&gt;())
            {
                if (!string.IsNullOrEmpty(contactItem.FullName))
                {
                    contactItem.FileAs = contactItem.FullName;
                    //contactItem.Save();
                }
            }
        }
    }
    app.Quit();
}
</code></pre>

<p>I think you would agree that this code is far better than the first example. And the difference becomes more dramatic as the complexity grows.</p>
]]></content>
  </entry>
  
</feed>
