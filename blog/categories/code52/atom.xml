<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code52 | Jake Ginnivan's blog]]></title>
  <link href="http://JakeGinnivan.github.io/blog/categories/code52/atom.xml" rel="self"/>
  <link href="http://JakeGinnivan.github.io/"/>
  <updated>2014-01-05T16:26:22+00:00</updated>
  <id>http://JakeGinnivan.github.io/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Markpad Performance Push]]></title>
    <link href="http://JakeGinnivan.github.io/markpad-performance-push/"/>
    <updated>2012-08-12T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/markpad-performance-push</id>
    <content type="html"><![CDATA[<p>If you haven&rsquo;t seen Markpad, think Windows Live Writer, but for Jekyll, Pretzel, FunnelWeb blogs, and also editing normal markdown files.</p>

<p><img src="/assets/posts/2012-08-12-markpad-performance-push/screenshot.png" alt="MarkPad" /></p>

<p>While flying back from Oslo and <a href="http://www.ndcoslo.com/">NDC</a> I spent probably 12+ hours of my ~20 hours of flying working on improving performance in MarkPad and cleaning up the codebase. This is documenting the most significant change.</p>

<!-- more -->


<h1>Hosting Awesomium in it&rsquo;s own AppDomain</h1>

<p>This was by far the biggest performance win for us, we moved Awesomium (the .net wrapper around the Chrome rendering engine) into it&rsquo;s own AppDomain, and show &lsquo;Preview Loading&hellip;&rsquo; much like visual studio does for it&rsquo;s designer.</p>

<p>Basically the way it works is we have a HtmlPreview.xaml control which is pretty simple:</p>

<pre><code>&lt;UserControl x:Class="MarkPad.PreviewControl.HtmlPreview"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             Loaded="HtmlPreviewLoaded"&gt;
  &lt;UserControl.Effect&gt;
    &lt;DropShadowEffect BlurRadius="10"
                      Color="Black"
                      Opacity="0.25"
                      Direction="270" /&gt;
  &lt;/UserControl.Effect&gt;

  &lt;Border BorderThickness="0"
          Background="White"&gt;
    &lt;TextBlock Text="Preview loading..."
               HorizontalAlignment="Center"
               VerticalAlignment="Center" /&gt;
  &lt;/Border&gt;
&lt;/UserControl&gt;
</code></pre>

<p>The magic is inside the Loaded event of this control:</p>

<pre><code>private void HtmlPreviewLoaded(object sender, RoutedEventArgs e)
{
    Loaded -= HtmlPreviewLoaded;
    var context = TaskScheduler.FromCurrentSynchronizationContext();

    //We are hosting the Awesomium preview in another appdomain so our main UI thread does not take the hit
    hostAppDomain = AppDomain.CreateDomain("HtmlPreviewDomain");
    var filename = FileName;

    // create the AppDomain on a new thread as we want to ensure it is an 
    // STA thread as this makes life easier for creating UI components
    var thread = new Thread(() =&gt;
    {
        var awesomiumHostType = typeof(AwesomiumHost);
        host = (AwesomiumHost)hostAppDomain.CreateInstanceAndUnwrap(awesomiumHostType.Assembly.FullName, awesomiumHostType.FullName,
        false, BindingFlags.Default, null, new object[] { filename, BaseDirectory }, CultureInfo.CurrentCulture, null);

        host.SetHtml(content);

        var controlHandle = host.ControlHandle;

        Task.Factory.StartNew(() =&gt;
        {
            //Delay until preview control has loaded before creating content host
            host.LoadedWaitHandle.WaitOne();

            // We need to invoke on the Markpad dispatcher, we are currently in the host appdomains STA Thread.
            Dispatcher.BeginInvoke(new Action(() =&gt;
            {
                hwndContentHost = new HwndContentHost(controlHandle);
                //Without the border we don't get the dropshadows
                Content = new Border
                {
                    Background = Brushes.White,
                    Padding = new Thickness(3),
                    Child = hwndContentHost
                };
            }));
        }, TaskCreationOptions.LongRunning);

        host.Run();
        //I can't get this unloading without an error, 
        // I am gathering Application.Shutdown is causing the appdomain to shutdown too
        //AppDomain.Unload(hostAppDomain);
    });

    thread.SetApartmentState(ApartmentState.STA);
    thread.Start();
}
</code></pre>

<p>So what does this actually do!</p>

<p>First we create the AppDomain, and spin up a dedicated thread which will be the UI thread of new AppDomain.</p>

<pre><code>hostAppDomain = AppDomain.CreateDomain("HtmlPreviewDomain");

var thread = new Thread(() =&gt;
{
    // We initialise it all in here
});

thread.SetApartmentState(ApartmentState.STA);
thread.Start();
</code></pre>

<p>Inside this new thread, we create an instance of the AwesomiumHost, which is a class which can be marshalled across AppDomains</p>

<pre><code>public class AwesomiumHost : MarshalByRefObject, IDisposable
{
    public string FileName { get; private set; }
    public string Html { get; set; }
    public double ScrollPercentage { get; set; }

    public IntPtr ControlHandle { get; }
    public ManualResetEvent LoadedWaitHandle { get; }

    public void SetHtml(string content);
    public void WbProcentualZoom();
    public void Print();
    public void Run();

    public void Dispose();
}
</code></pre>

<p>So we create the instance and unwrap it:</p>

<pre><code>var awesomiumHostType = typeof(AwesomiumHost);
host = (AwesomiumHost)hostAppDomain.CreateInstanceAndUnwrap(awesomiumHostType.Assembly.FullName, awesomiumHostType.FullName,
        false, BindingFlags.Default, null, new object[] { filename, BaseDirectory }, CultureInfo.CurrentCulture, null);

host.SetHtml(content);
var controlHandle = host.ControlHandle;
</code></pre>

<p>This has gone and created the control, and got the ControlHandle which we need to host WPF controls across appdomains, there is some nasty code in the <code>static long CreateWindowHandle(Visual frameworkElement)</code> method if you want to know how to do it.</p>

<p>We then start a long running task (background operation in the preview appdomain) which blocks until the control has fully loaded (the LoadedWaitHandle is set once the Loaded event fires on the Awesomium control).</p>

<pre><code>Task.Factory.StartNew(() =&gt;
{
    //Delay until preview control has loaded before creating content host
    host.LoadedWaitHandle.WaitOne();

    // We need to invoke on the Markpad dispatcher, we are currently in the host appdomains STA Thread.
    Dispatcher.BeginInvoke(new Action(() =&gt;
    {
        hwndContentHost = new HwndContentHost(controlHandle);
        //Without the border we don't get the dropshadows
        Content = new Border
        {
            Background = Brushes.White,
            Padding = new Thickness(3),
            Child = hwndContentHost
        };
    }));
}, TaskCreationOptions.LongRunning);
</code></pre>

<p>We then invoke the creation of the content host on Markpads UI thread, and replace the content of the UserControl with the MarkPad preview.</p>

<p>There are a few more things, but this should help you follow the Markpad codebase if you ever want to host a WPF control in another AppDomain :)</p>

<h2>Links</h2>

<p>Go grab the source, have a look. If you are so inclined you can pick up a issue, and submit a pull request!</p>

<p><a href="https://github.com/Code52/DownmarkerWPF">https://github.com/Code52/DownmarkerWPF</a></p>
]]></content>
  </entry>
  
</feed>
