<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C# | Jake Ginnivan's blog]]></title>
  <link href="http://JakeGinnivan.github.io/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="http://JakeGinnivan.github.io/"/>
  <updated>2014-01-05T16:26:22+00:00</updated>
  <id>http://JakeGinnivan.github.io/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redirecting Process Output]]></title>
    <link href="http://JakeGinnivan.github.io/redirecting-process-output/"/>
    <updated>2013-04-05T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/redirecting-process-output</id>
    <content type="html"><![CDATA[<p>I sometimes have the need to shell a process and redirect the output. But I often have issues with deadlocks between processes and other random issues.</p>

<p>Based on a blog post that Lucian Wischik posted a while back at <a href="http://blogs.msdn.com/b/lucian/archive/2008/12/29/system-diagnostics-process-redirect-standardinput-standardoutput-standarderror.aspx">http://blogs.msdn.com/b/lucian/archive/2008/12/29/system-diagnostics-process-redirect-standardinput-standardoutput-standarderror.aspx</a> I have created a c# version of his code which makes it nice and easy.</p>

<!-- more -->


<h1>Usage</h1>

<pre><code>string stdOut;
string stdErr;
var processStartInfo = new ProcessStartInfo(process, args)
{
    UseShellExecute = false,
    RedirectStandardError = true,
    RedirectStandardInput = true,
    RedirectStandardOutput = true
};
Process.Start(processStartInfo).InputAndOutputToEnd(string.Empty, out stdOut, out stdErr);

Console.Write(stdOut);
Console.Write(stdErr);
</code></pre>

<h1>The Code</h1>

<pre><code>public static class ProcessExtensions
{
    public static void InputAndOutputToEnd(this Process p, string standardInput, out string standardOutput, out string standardError)
    {
        if (p == null)
            throw new ArgumentException("p must be non-null");
        // Assume p has started. Alas there's no way to check.
        if (p.StartInfo.UseShellExecute)
            throw new ArgumentException("Set StartInfo.UseShellExecute to false");
        if ((p.StartInfo.RedirectStandardInput != (standardInput != null)))
            throw new ArgumentException("Provide a non-null Input only when StartInfo.RedirectStandardInput");
        //
        var outputData = new InputAndOutputToEndData();
        var errorData = new InputAndOutputToEndData();

        //
        if (p.StartInfo.RedirectStandardOutput)
        {
            outputData.Stream = p.StandardOutput;
            outputData.Thread = new System.Threading.Thread(InputAndOutputToEndProc);
            outputData.Thread.Start(outputData);
        }
        if (p.StartInfo.RedirectStandardError)
        {
            errorData.Stream = p.StandardError;
            errorData.Thread = new System.Threading.Thread(InputAndOutputToEndProc);
            errorData.Thread.Start(errorData);
        }
        //
        if (p.StartInfo.RedirectStandardInput)
        {
            p.StandardInput.Write(standardInput);
            p.StandardInput.Close();
        }
        //
        if (p.StartInfo.RedirectStandardOutput)
        {
            outputData.Thread.Join();
            standardOutput = outputData.Output;
        }
        else
            standardOutput = string.Empty;

        if (p.StartInfo.RedirectStandardError)
        {
            errorData.Thread.Join();
            standardError = errorData.Output;
        }
        else
            standardError = string.Empty;

        if (outputData.Exception != null)
            throw outputData.Exception;
        if (errorData.Exception != null)
            throw errorData.Exception;
    }

    private class InputAndOutputToEndData
    {
        public System.Threading.Thread Thread;
        public System.IO.StreamReader Stream;
        public string Output;
        public Exception Exception;
    }

    private static void InputAndOutputToEndProc(object data)
    {
        var ioData = (InputAndOutputToEndData)data;
        try
        {
            ioData.Output = ioData.Stream.ReadToEnd();
        }
        catch (Exception e)
        {
            ioData.Exception = e;
        }
    }
}
</code></pre>

<p>Hope this is useful</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM, Design Time vs IoC Usage]]></title>
    <link href="http://JakeGinnivan.github.io/wpf-mvvm-thoughs/"/>
    <updated>2011-07-21T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/wpf-mvvm-thoughs</id>
    <content type="html"><![CDATA[<h1>The problems</h1>

<p>Lets start with the problems we want to solve with our solution</p>

<ul>
<li>Blend Design time support</li>
<li>Resharper binding validation support</li>
<li>No using ServiceLocator, DI only</li>
<li>ViewModels should be testable</li>
</ul>


<p>Frameworks like Magellan solve these sort of issues in other ways, but if you don&rsquo;t want to take on a framework then maybe an approach like this may help you get started.</p>

<!-- more -->


<h1>My approach</h1>

<p>I find that once you progress past a basic application with simple interactions that often you need views to interact with each other, this could be returning data from a modal dialogue or anything.</p>

<p>One thing we are often told is we should develop against interfaces, not implementations. I think this applies to views as well, so lets create an IView interface.</p>

<pre><code>public interface IView
{
}
</code></pre>

<p>Now I want to be able to tell the calling viewmodel if I was cancelled, or possibly return data, so we will create three more interfaces and a few classes:</p>

<pre><code>public interface IDialogueView : IView
{
    void DialogueDisplayed();
    void DialogueClosed();
}

public interface IDialogueView&lt;TResult&gt; : IDialogueView
{
    event EventHandler&lt;DialogueResultEventArgs&lt;TResult&gt;&gt; Finished;
}

public interface IDialogueViewWithoutResult : IDialogueView
{
    event EventHandler&lt;DialogueResultEventArgs&gt; Finished;
}

public class DialogueResultEventArgs : EventArgs
{
    public DialogueResultEventArgs(bool cancelled)
    {
        Cancelled = cancelled;
    }

    public bool Cancelled { get; private set; }

    public static DialogueResultEventArgs EmptyResult = new DialogueResultEventArgs(false);
    public static DialogueResultEventArgs CancelledResult = new DialogueResultEventArgs(true);
}

public class DialogueResultEventArgs&lt;T&gt; : EventArgs
{
    public DialogueResultEventArgs(Exception error)
    {
        Result = new DialogueResult&lt;T&gt;(error);
    }

    public DialogueResultEventArgs(T result)
    {
        Result = new DialogueResult&lt;T&gt;(result);
    }

    public static DialogueResultEventArgs&lt;T&gt; Cancelled()
    {
        return new DialogueResultEventArgs&lt;T&gt; { Result = DialogueResult&lt;T&gt;.CancelledResult() };
    }

    private DialogueResultEventArgs() { }

    public DialogueResult&lt;T&gt; Result { get; private set; }
}
</code></pre>

<p>Then we need some way for our ViewModels to interact with other Views using these interfaces, enter IUIService</p>

<pre><code>public interface IUIService
{
    /// &lt;summary&gt;
    /// Shows a view in dialogue mode. The view will return a result. This call is blocking.
    /// &lt;/summary&gt;
    /// &lt;param name="dialogueView"&gt;The dialogue view.&lt;/param&gt;
    DialogueResult&lt;TResult&gt; ShowDialogue&lt;TResult&gt;(IDialogueView&lt;TResult&gt; dialogueView);

    /// &lt;summary&gt;
    /// Shows a view in dialogue mode. No result will be returend. This call is blocking.
    /// &lt;/summary&gt;
    /// &lt;param name="dialogueView"&gt;The dialogue view.&lt;/param&gt;
    DialogueResult ShowDialogue(IDialogueViewWithoutResult dialogueView);
}
</code></pre>

<h2>Creating a new view</h2>

<p>One of our requirements is that we want to support blend, this is pretty easy but I think that the view shells should always be created by the developers. If you have designers, create the empty view for them, wire it up, then hand over to them for them to do their magic. As much as Microsoft has made the developer/designer story much better, you still have to weigh up the pros and cons of trying to get the designers to do too much. Either they learn a basic bit of coding to get a new view setup, or they rely on the devs to create and wire up the empty view.</p>

<p>Start off and create a new &lsquo;WPF Window&rsquo;. Then we define an interface for it in the code behind.</p>

<pre><code>public partial class MyView : IMyView
{
    public MyView(MyViewModel viewModel)
    {
        _viewModel = viewModel;
        DataContext = _viewModel;
        InitializeComponent();
    }

    public void DialogueDisplayed()
    {
        _viewModel.Initialise();
    }

    public void DialogueClosed()
    {
    }

    public event EventHandler&lt;DialogueResultEventArgs&lt;SomeData&gt;&gt; Finished
    {
        add { _viewModel.Finished += value; }
        remove { _viewModel.Finished -= value; }
    }
}

public interface IMyView : IDialogueView&lt;SomeData&gt;
{ }
</code></pre>

<p>Doing this requires some basic coding, but allows full IoC support, and allows the viewmodel to raise the finished event, which will cause the UIService to close the window and return to the caller. It also gives a nice place to hook into things.
In my current projects, we actually define all windows as UserControls, and our UI server creates the window with custom chrome and gives us full control over everything. It is working very well.</p>

<p>Then lets look at the Xaml.</p>

<pre><code>&lt;Window x:Class="WpfApplication3.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        mc:Ignorable="d"
        d:DataContext="{d:DesignInstance MainViewModel, IsDesignTimeCreatable=True}"&gt;
    &lt;Grid&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>

<p>In my current project we also have an attached behaviour which allows us to specify a provider to set the datacontext. We leave the d:DataContext in there so we get R# support for our bindings =)</p>

<p>Next chance I get, I was thinking that doing something like this in the viewmodel might work quite well.</p>

<h1>IoC &ndash; Putting it together</h1>

<p>In our appliation startup, we need to register out IoC container, I am using Autofac. This is my registration</p>

<pre><code>private void ApplicationStartup(object sender, StartupEventArgs e)
{
    var containerBuilder = new ContainerBuilder();
    containerBuilder.RegisterType&lt;UIService&gt;().As&lt;IUIService&gt;();
    containerBuilder.RegisterType&lt;SomeService&gt;().As&lt;ISomeService&gt;();
    containerBuilder
        .RegisterAssemblyTypes(typeof(App).Assembly)
        .AssignableTo&lt;IView&gt;()
        .AsImplementedInterfaces();
    containerBuilder
        .RegisterAssemblyTypes(typeof(App).Assembly)
        .AssignableTo&lt;ViewModelBase&gt;()
        .AsSelf();
    var container = containerBuilder.Build();
    container.Resolve&lt;IUIService&gt;().ShowDialogue(container.Resolve&lt;IMainView&gt;());
}
</code></pre>

<p>I register my UIService, another random service, then use the assembly scanning features to register viewmodels and views. I then resolve my UIService, and show my IMainViewModel!</p>

<h1>Design Time and Runtime ViewModel wireup</h1>

<p><code>Note:</code> I have not used this technique in a production project, but think it would be cool to try out and think it would be better than the setup I am using now.</p>

<p>We add default constructor to our viewmodel:</p>

<pre><code>public MainWindow() : this(new MainViewModel())
{
}
</code></pre>

<p>We then setup our viewmodel, which will look like:</p>

<pre><code>public class MainViewModel : ViewModelBase
{
    public MainViewModel()
    {
        this.PopulateDesignTimeData().With&lt;MainViewModelData&gt;();
    }

    public MainViewModel(ISomeService someService)
    {
        //To show some DI at runtime
        SomeProperty = someService.GetAValue();
    }

    public string SomeProperty { get; set; }
    public event EventHandler&lt;DialogueResultEventArgs&gt; Finished;

    protected void OnFinished(DialogueResultEventArgs e)
    {
        var handler = Finished;
        if (handler != null) handler(this, e);
    }
}
</code></pre>

<p>Notice in our default contructor we call <code>this.PopulateDesignTimeData().With&lt;MainViewModelData&gt;()</code>? Here is the MainViewModelData class:</p>

<pre><code>public class MainViewModelData : IDesignTimeViewModelPopulator&lt;MainViewModel&gt;
{
    public void Populate(MainViewModel viewModel)
    {
        viewModel.SomeProperty = "blah";
    }
}
</code></pre>

<p>Because of the way our IoC containers work, they will always choose the most specific constructor they can. If it cannot find the dependencies it will default back to the default constructor, which will throw a Debug.Assert because it is not in design time mode.</p>

<h1>Source</h1>

<p><a href="/get/downloads/WpfApplication3.zip">Download example project</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[No More R# Warnings for nHibernate Aliases]]></title>
    <link href="http://JakeGinnivan.github.io/nhibernate-alias-warnings/"/>
    <updated>2011-07-21T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/nhibernate-alias-warnings</id>
    <content type="html"><![CDATA[<p>I dislike having R# warnings in code bases I work on, and try to leave every class I work on having a green status.</p>

<p>Here is a scenario</p>

<pre><code>var entryAlias = default(Entry);
var entries = session.QueryOver&lt;Entry&gt;(()=&gt;entryAlias);
</code></pre>

<p>In the above scenario R# will warn that entryAlias is always null, which is is, but I don&rsquo;t care, nHibernate is simply getting the type from the expression.</p>

<!-- more -->


<p>So I have created a simple static class:</p>

<pre><code>/// &lt;summary&gt;
/// Simple helper class to remove r# warnings when using nHibernate aliases
/// &lt;/summary&gt;
public static class Alias
{
    public static T For&lt;T&gt;()
    {
        return default(T);
    }
}
</code></pre>

<p>And we turn the above code into:</p>

<pre><code>var entryAlias = Alias.For&lt;Entry&gt;();
var entries = session.QueryOver&lt;Entry&gt;(()=&gt;entryAlias);
</code></pre>

<p>Which does not warn.</p>

<p>Happy Resharpering</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Retry.For]]></title>
    <link href="http://JakeGinnivan.github.io/retry-for-class/"/>
    <updated>2011-03-20T00:00:00+00:00</updated>
    <id>http://JakeGinnivan.github.io/retry-for-class</id>
    <content type="html"><![CDATA[<p>With UI automation, you are constantly dealing with race conditions, especially in a good WPF app which lazy loads most things, and while we have put a lot of good helpers in place (WaitWhileBusy etc), there are still times where a button does not enable quick enough, or a windows is opening and if you do not have automatic retry enabled you will have quite fragile UI automation tests.</p>

<p>This is where my Retry static class comes in handy.</p>

<!-- more -->


<h2>Usage</h2>

<pre><code>var element = Retry.ForDefault(
                  () =&gt; screen.WhiteWindow.Get(searchCriteria),
                  b =&gt; (bool)b.AutomationElement.GetCurrentPropertyValue(AutomationElement.IsOffscreenProperty, false));
</code></pre>

<p>or for retrying if a locked log file is encountered (app still shutting down, or in middle of a write)</p>

<pre><code>Retry.For(() =&gt; File.Exists(@"C:\Logs\Terminal.log"), 5)
</code></pre>

<p>It will automatically retry if a value type is default, i.e if you call</p>

<pre><code>Retry.For&lt;int&gt;(()=&gt;default(int), 5); //Will retry for 5 seconds, then return default(int)
</code></pre>

<p>And some more of the default conditions that cause retry</p>

<ul>
<li>Exception thrown</li>
<li>Value type == default(type)</li>
<li>Reference type == null</li>
<li>bool == false</li>
</ul>


<p>You can also override the default conditions with a predicate.</p>

<h2>Code</h2>

<p>public static class Retry</p>

<pre><code>{
    public const int WindowWaitDefault = 30;
    public const int ElementWaitDefault = 10;

    public static Window ForDefault(Func&lt;Window&gt; getMethod)
    {
        return For(getMethod, WindowWaitDefault);
    }

    public static T ForDefault&lt;T&gt;(Func&lt;T&gt; getMethod)
    {
        return For(getMethod, ElementWaitDefault);
    }

    public static Window ForDefault(Func&lt;Window&gt; getMethod, Predicate&lt;Window&gt; shouldRetry)
    {
        return For(getMethod, shouldRetry, WindowWaitDefault);
    }

    public static T ForDefault&lt;T&gt;(Func&lt;T&gt; getMethod, Predicate&lt;T&gt; shouldRetry)
    {
        return For(getMethod, shouldRetry, ElementWaitDefault);
    }

    /// &lt;summary&gt;
    /// Retrys until action does not throw an exception
    /// &lt;/summary&gt;
    /// &lt;param name="action"&gt;The action.&lt;/param&gt;
    /// &lt;param name="retryForSeconds"&gt;The retry for seconds.&lt;/param&gt;
    public static void For(Action action, int retryForSeconds)
    {
        var startTime = DateTime.Now;
        while (DateTime.Now.Subtract(startTime).TotalSeconds &lt; retryForSeconds)
        {
            try
            {
                action();
                return;
            }
            catch (Exception)
            {
                Thread.Sleep(500);
                continue;
            }
        }

        action();
    }

    public static bool For(Func&lt;bool&gt; getMethod, int retryForSeconds)
    {
        return For(getMethod, g =&gt; !g, retryForSeconds);
    }

    public static T For&lt;T&gt;(Func&lt;T&gt; getMethod, int retryForSeconds)
    {
        //If T is a value type, by default we should retry if the value is default
        //Reference types will return fase, so our predecate will always pass
        return For(getMethod, IsValueTypeAndDefault, retryForSeconds);
    }

    public static T For&lt;T&gt;(Func&lt;T&gt; getMethod, Predicate&lt;T&gt; shouldRetry, int retryForSeconds)
    {
        var startTime = DateTime.Now;
        T element;
        while (DateTime.Now.Subtract(startTime).TotalSeconds &lt; retryForSeconds)
        {
            try
            {
                element = getMethod();
            }
            catch (Exception)
            {
                Thread.Sleep(500);
                continue;
            }

            //Making it safe for bool and value types and reference types
            if (typeof(T) == typeof(bool) &amp;&amp; !shouldRetry(element))
                return element;

            if (typeof(T) != typeof(bool) &amp;&amp;
                !IsReferenceTypeAndIsNull(element) &amp;&amp;
                !shouldRetry(element))
            {
                return element;
            }

            Thread.Sleep(500);
        }

        element = getMethod();
        return element;
    }

    private static bool IsReferenceTypeAndIsNull&lt;T&gt;(T element)
    {
        return (!(typeof(T).IsValueType) &amp;&amp; ReferenceEquals(element, null));
    }

    private static bool IsValueTypeAndDefault&lt;T&gt;(T element)
    {
        return (typeof(T).IsValueType &amp;&amp; element.Equals(default(T)));
    }
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C# Command Line Argument Parser]]></title>
    <link href="http://JakeGinnivan.github.io/c-sharp-argument-parser/"/>
    <updated>2010-08-21T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/c-sharp-argument-parser</id>
    <content type="html"><![CDATA[<p>I know this has been done to death but nothing I found did the job for me so I started with the one that fitted my needs the most then edited from there.</p>

<p>Original source: <a href="http://www.codeproject.com/KB/recipes/command_line.aspx">http://www.codeproject.com/KB/recipes/command_line.aspx</a></p>

<p>I have a few specific requirements:</p>

<ul>
<li>It must support lists, or the same argument specified multiple times. If an argument has comma’s in it then it will be treated as a list and split on the comma.</li>
<li>It must support paths with a trailing \ ie. –arg:&ldquo;c:\Users\ginnivanj\My Path\&rdquo;</li>
<li>Has support for flags.</li>
</ul>


<!-- more -->


<p><img src="/get/screenshots/argPaserClassDiagram.png" alt="Class Diagram" /></p>

<h1>Example Usage</h1>


<p>There are two ways you can start using this class, I have created a SplitCommandLine function which ignores escaped quotes, this is needed for path support, the trailing \ on the path causes the quote to be taken literally.</p>

<p>Using SplitCommandLine:</p>

<pre><code>var commandLine = Environment.CommandLine;
var splitCommandLine = Arguments.SplitCommandLine(commandLine);

var arguments = new Arguments(splitCommandLine);
</code></pre>

<p>Letting windows do it:</p>

<pre><code>static int Main(string[] args)
{
    _args = new Arguments(args);
}
</code></pre>

<h2>Example Arguments</h2>


<blockquote><p>Argument: –flag  <br />
Usage: args.IsTrue(&ldquo;flag&rdquo;);  <br />
Result: true <br /></p>

<p>Argument: –arg:MyValue  <br />
Usage: args.Single(&ldquo;arg&rdquo;);  <br />
Result: MyValue <br /></p>

<p><p>Argument: –arg &ldquo;My Value&rdquo; <br />
Usage: args.Single(&ldquo;arg&rdquo;);  <br />
Result: ‘My Value’ <br /></p>

<p>Argument: /arg=Value /arg=Value2  <br />
Usage: args[&ldquo;arg&rdquo;]  <br />
Result: new string[] {&ldquo;Value&rdquo;, &ldquo;Value2&rdquo;} <br /></p>

<p>Argument: /arg=&ldquo;Value,Value2&rdquo;  <br />
Usage: args[&ldquo;arg&rdquo;]  <br />
Result: new string[] {&ldquo;Value&rdquo;, &ldquo;Value2&rdquo;} <br /></p></blockquote>

<p>As you can see it is very flexible, it support [–/]arg[:=<space>]value and with the list support it makes it really useful and adaptable.</p>

<p>I have tried to cover as many of the different options with unit tests to make sure it is robust.</p>

<h1>Arguments Class</h1>


<pre><code>/// &lt;summary&gt;
/// Arguments class
/// &lt;/summary&gt;
public class Arguments
{ 
    /// &lt;summary&gt;
    /// Splits the command line. When main(string[] args) is used escaped quotes (ie a path "c:\folder\")
    /// Will consume all the following command line arguments as the one argument. 
    /// This function ignores escaped quotes making handling paths much easier.
    /// &lt;/summary&gt;
    /// &lt;param name="commandLine"&gt;The command line.&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public static string[] SplitCommandLine(string commandLine)
    {
        var translatedArguments = new StringBuilder(commandLine);
        var escaped = false;
        for (var i = 0; i &lt; translatedArguments.Length; i++)
        {
            if (translatedArguments[i] == '"')
            {
                escaped = !escaped;
            }
            if (translatedArguments[i] == ' ' &amp;&amp; !escaped)
            {
                translatedArguments[i] = '\n';
            }
        }

        var toReturn = translatedArguments.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
        for (var i = 0; i &lt; toReturn.Length; i++)
        {
            toReturn[i] = RemoveMatchingQuotes(toReturn[i]);
        }
        return toReturn;
    }

    public static string RemoveMatchingQuotes(string stringToTrim)
    {
        var firstQuoteIndex = stringToTrim.IndexOf('"');
        var lastQuoteIndex = stringToTrim.LastIndexOf('"');
        while (firstQuoteIndex != lastQuoteIndex)
        {
            stringToTrim = stringToTrim.Remove(firstQuoteIndex, 1);
            stringToTrim = stringToTrim.Remove(lastQuoteIndex - 1, 1); //-1 because we've shifted the indicies left by one
            firstQuoteIndex = stringToTrim.IndexOf('"');
            lastQuoteIndex = stringToTrim.LastIndexOf('"');
        }

        return stringToTrim;
    }

    private readonly Dictionary&lt;string, Collection&lt;string&gt;&gt; _parameters;
    private string _waitingParameter;

    public Arguments(IEnumerable&lt;string&gt; arguments)
    {
        _parameters = new Dictionary&lt;string, Collection&lt;string&gt;&gt;();

        string[] parts;

        //Splits on beginning of arguments ( - and -- and / )
        //And on assignment operators ( = and : )
        var argumentSplitter = new Regex(@"^-{1,2}|^/|=|:",
            RegexOptions.IgnoreCase | RegexOptions.Compiled);

        foreach (var argument in arguments)
        {
            parts = argumentSplitter.Split(argument, 3);
            switch (parts.Length)
            {
                case 1:
                    AddValueToWaitingArgument(parts[0]);
                    break;
                case 2:
                    AddWaitingArgumentAsFlag();

                    //Because of the split index 0 will be a empty string
                    _waitingParameter = parts[1];
                    break;
                case 3:
                    AddWaitingArgumentAsFlag();

                    //Because of the split index 0 will be a empty string
                    string valuesWithoutQuotes = RemoveMatchingQuotes(parts[2]);

                    AddListValues(parts[1], valuesWithoutQuotes.Split(','));
                    break;
            }
        }

        AddWaitingArgumentAsFlag();
    }

    private void AddListValues(string argument, IEnumerable&lt;string&gt; values)
    {
        foreach (var listValue in values)
        {
            Add(argument, listValue);
        }
    }

    private void AddWaitingArgumentAsFlag()
    {
        if (_waitingParameter == null) return;

        AddSingle(_waitingParameter, "true");
        _waitingParameter = null;
    }

    private void AddValueToWaitingArgument(string value)
    {
        if (_waitingParameter == null) return;

        value = RemoveMatchingQuotes(value);

        Add(_waitingParameter, value);
        _waitingParameter = null;
    }

    /// &lt;summary&gt;
    /// Gets the count.
    /// &lt;/summary&gt;
    /// &lt;value&gt;The count.&lt;/value&gt;
    public int Count
    {
        get
        {
            return _parameters.Count;
        }
    }

    /// &lt;summary&gt;
    /// Adds the specified argument.
    /// &lt;/summary&gt;
    /// &lt;param name="argument"&gt;The argument.&lt;/param&gt;
    /// &lt;param name="value"&gt;The value.&lt;/param&gt;
    public void Add(string argument, string value)
    {
        if (!_parameters.ContainsKey(argument))
            _parameters.Add(argument, new Collection&lt;string&gt;());

        _parameters[argument].Add(value);
    }

    public void AddSingle(string argument, string value)
    {
        if (!_parameters.ContainsKey(argument))
            _parameters.Add(argument, new Collection&lt;string&gt;());
        else
            throw new ArgumentException(string.Format("Argument {0} has already been defined", argument));

        _parameters[argument].Add(value);
    }

    public void Remove(string argument)
    {
        if (_parameters.ContainsKey(argument))
            _parameters.Remove(argument);
    }

    /// &lt;summary&gt;
    /// Determines whether the specified argument is true.
    /// &lt;/summary&gt;
    /// &lt;param name="argument"&gt;The argument.&lt;/param&gt;
    /// &lt;returns&gt;
    ///     &lt;c&gt;true&lt;/c&gt; if the specified argument is true; otherwise, &lt;c&gt;false&lt;/c&gt;.
    /// &lt;/returns&gt;
    public bool IsTrue(string argument)
    {
        AssertSingle(argument);

        var arg = this[argument];

        return arg != null &amp;&amp; arg[0].Equals("true", StringComparison.OrdinalIgnoreCase);
    }

    private void AssertSingle(string argument)
    {
        if (this[argument] != null &amp;&amp; this[argument].Count &gt; 1)
            throw new ArgumentException(string.Format("{0} has been specified more than once, expecting single value", argument));
    }

    public string Single(string argument)
    {
        AssertSingle(argument);

        //only return value if its NOT true, there is only a single item for that argument
        //and the argument is defined
        if (this[argument] != null &amp;&amp; !IsTrue(argument))
            return this[argument][0];

        return null;
    }

    public bool Exists(string argument)
    {
        return (this[argument] != null &amp;&amp; this[argument].Count &gt; 0);
    }

    /// &lt;summary&gt;
    /// Gets the &lt;see cref="System.Collections.ObjectModel.Collection&amp;lt;T&amp;gt;"/&gt; with the specified parameter.
    /// &lt;/summary&gt;
    /// &lt;value&gt;&lt;/value&gt;
    public Collection&lt;string&gt; this[string parameter]
    {
        get
        {
            return _parameters.ContainsKey(parameter) ? _parameters[parameter] : null;
        }
    }
}
</code></pre>

<h1>Unit Tests</h1>


<p>Tests use xUnit as the unit testing framework</p>

<pre><code>public class ArgumentsTests
{
    [Fact]
    public void ArgumentBooleanTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-testBool"
                                       };
        var target = new Arguments(args);
        Assert.True(target.IsTrue("testBool"));
    }

    [Fact]
    public void IsTrueDoesntExist()
    {
        IEnumerable&lt;string&gt; args = new string[]{};
        var target = new Arguments(args);
        Assert.False(target.IsTrue("doesntExist"));
    }

    [Fact]
    public void ArgumentDoubleDashesTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "--testArg=Value"
                                       };
        var target = new Arguments(args);
        Assert.Equal("Value", target.Single("testArg"));
    }

    [Fact]
    public void ArgumentSingleTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value"
                                       };
        var target = new Arguments(args);
        Assert.Equal(1, target["test"].Count);
        Assert.Equal("Value", target.Single("test"));
    }

    [Fact]
    public void ArgumentWithSpaceSeparatorTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-test Value");

        var target = new Arguments(args);
        Assert.Equal(1, target["test"].Count);
        Assert.Equal("Value", target.Single("test"));
    }

    [Fact]
    public void ArgumentWithSpaceSeparatorAndSpaceInValueTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-test \"Value With Space\"");

        var target = new Arguments(args);
        Assert.Equal(1, target["test"].Count);
        Assert.Equal("Value With Space", target.Single("test"));
    }

    [Fact]
    public void AddWaitingAsFlagTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-flag -test \"Value With Space\"");

        var target = new Arguments(args);
        Assert.Equal(2, target.Count);
        Assert.Equal(1, target["test"].Count);
        Assert.Equal("Value With Space", target.Single("test"));
        Assert.True(target.IsTrue("flag"));
    }

    [Fact]
    public void AddSingleTwiceTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-flag");

        var target = new Arguments(args);

        Assert.Throws&lt;ArgumentException&gt;(() =&gt; target.AddSingle("flag", "true"));
    }

    [Fact]
    public void FlagsTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-flag1 -flag2");

        var target = new Arguments(args);

        Assert.True(target.IsTrue("flag1"));
        Assert.True(target.IsTrue("flag2"));
    }

    [Fact]
    public void RemoveTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-flag1 -flag2");

        var target = new Arguments(args);

        Assert.True(target.IsTrue("flag1"));
        Assert.True(target.IsTrue("flag2"));
        target.Remove("flag1");
        Assert.False(target.Exists("flag1"));
        Assert.True(target.IsTrue("flag2"));
    }

    [Fact]
    public void SingleReturnsNullIfNotDefinedTest()
    {

        var target = new Arguments(new string[]{});

        Assert.False(target.Exists("notDefined"));
        Assert.Null(target.Single("notDefined"));
    }

    [Fact]
    public void ExistsTest()
    {
        IEnumerable&lt;string&gt; args = Arguments.SplitCommandLine("-flag1");

        var target = new Arguments(args);

        Assert.True(target.Exists("flag1"));
    }

    [Fact]
    public void ArgumentListTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           "-test:Value2"
                                       };
        var target = new Arguments(args);
        Assert.Equal(2, target["test"].Count);
        Assert.Equal("Value", target["test"][0]);
        Assert.Equal("Value2", target["test"][1]);
    }

    [Fact]
    public void ArgumentPathTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           @"-test:C:\Folder\"
                                       };
        var target = new Arguments(args);
        Assert.Equal(2, target["test"].Count);
        Assert.Equal("Value", target["test"][0]);
        Assert.Equal(@"C:\Folder\", target["test"][1]);
    }

    [Fact]
    public void ArgumentQuotedPathTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           "-test:\"C:\\Folder\\\""
                                       };
        var target = new Arguments(args);
        Assert.Equal(2, target["test"].Count);
        Assert.Equal("Value", target["test"][0]);
        Assert.Equal("C:\\Folder\\", target["test"][1]);
    }

    [Fact]
    public void ArgumentQuotedPathWithSpaceTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           "-test:\"C:\\Folder Name\\\""
                                       };
        var target = new Arguments(args);
        Assert.Equal(2, target["test"].Count);
        Assert.Equal("Value", target["test"][0]);
        Assert.Equal("C:\\Folder Name\\", target["test"][1]);
    }

    [Fact]
    public void ArgumentQuotedPathWithSpaceAndFollowingArgTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           "-test:\"C:\\Folder Name\\\"",
                                           "-testPath:\"C:\\Folder2\\\"",
                                           "-boolArg"
                                       };

        var target = new Arguments(args);
        Assert.Equal(2, target["test"].Count);
        Assert.Equal(@"C:\Folder2\", target.Single("testPath"));
        Assert.True(target.IsTrue("boolArg"));

        Assert.Equal("Value", target["test"][0]);
        Assert.Equal("C:\\Folder Name\\", target["test"][1]);
    }

    [Fact]
    public void ArgumentListRequestSingleThrowsExceptionTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-test:Value",
                                           "-test:Value2"
                                       };

        var target = new Arguments(args);
        //Should throw Argument exception because test is defined more than once
        Assert.Throws&lt;ArgumentException&gt;(() =&gt; target.Single("test"));
    }

    [Fact]
    public void ArgumentCommaListTest()
    {
        IEnumerable&lt;string&gt; args = new[]
                                       {
                                           "-testList:Value,Value2,Value3"
                                       };

        var target = new Arguments(args);
        Assert.Equal(3, target["testList"].Count);

        Assert.Equal("Value", target["testList"][0]);
        Assert.Equal("Value2", target["testList"][1]);
        Assert.Equal("Value3", target["testList"][2]);
    }

    [Fact]
    public void BlogExample()
    {
        const string commandLine = "-u -d -mdb=\"c:\\entries.mdb\" -xml=\"j:\\\"";

        var target = new Arguments(Arguments.SplitCommandLine(commandLine));

        Assert.Equal("c:\\entries.mdb", target.Single("mdb"));
        Assert.Equal("j:\\", target.Single("xml"));
    }
}
</code></pre>
]]></content>
  </entry>
  
</feed>
