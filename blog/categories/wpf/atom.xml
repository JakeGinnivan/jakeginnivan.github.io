<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Wpf | Jake Ginnivan's blog]]></title>
  <link href="http://JakeGinnivan.github.io/blog/categories/wpf/atom.xml" rel="self"/>
  <link href="http://JakeGinnivan.github.io/"/>
  <updated>2014-01-05T21:44:09+00:00</updated>
  <id>http://JakeGinnivan.github.io/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pack URI in Unit Tests]]></title>
    <link href="http://JakeGinnivan.github.io/pack-uri-in-unit-tests/"/>
    <updated>2013-09-16T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/pack-uri-in-unit-tests</id>
    <content type="html"><![CDATA[<p>I had a unit tests which constructed a pack uri, and I didn&rsquo;t want to abstract it (needless abstraction) so here is how I solved a few issues.</p>

<h2>Exception 1</h2>

<h3>System.UriFormatException : Invalid URI: Invalid port specified</h3>

<p>This one is pretty easy to fix, you can use the <code>PackUriHelper</code> which registers a few things in it&rsquo;s static ctor</p>

<pre><code>PackUriHelper.Create(new Uri("reliable://0"))
</code></pre>

<h2>Exception 2</h2>

<h3>System.NotSupportedException : The URI prefix is not recognized</h3>

<p>This one is fixed by giving WPF the default resource assembly.</p>

<pre><code>System.Windows.Application.ResourceAssembly = typeof(App).Assembly;
</code></pre>

<p>Now you should be able to unit tests around pack uri&rsquo;s</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markpad Performance Push]]></title>
    <link href="http://JakeGinnivan.github.io/markpad-performance-push/"/>
    <updated>2012-08-12T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/markpad-performance-push</id>
    <content type="html"><![CDATA[<p>If you haven&rsquo;t seen Markpad, think Windows Live Writer, but for Jekyll, Pretzel, FunnelWeb blogs, and also editing normal markdown files.</p>

<p><img src="/assets/posts/2012-08-12-markpad-performance-push/screenshot.png" alt="MarkPad" /></p>

<p>While flying back from Oslo and <a href="http://www.ndcoslo.com/">NDC</a> I spent probably 12+ hours of my ~20 hours of flying working on improving performance in MarkPad and cleaning up the codebase. This is documenting the most significant change.</p>

<!-- more -->


<h1>Hosting Awesomium in it&rsquo;s own AppDomain</h1>

<p>This was by far the biggest performance win for us, we moved Awesomium (the .net wrapper around the Chrome rendering engine) into it&rsquo;s own AppDomain, and show &lsquo;Preview Loading&hellip;&rsquo; much like visual studio does for it&rsquo;s designer.</p>

<p>Basically the way it works is we have a HtmlPreview.xaml control which is pretty simple:</p>

<pre><code>&lt;UserControl x:Class="MarkPad.PreviewControl.HtmlPreview"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             Loaded="HtmlPreviewLoaded"&gt;
  &lt;UserControl.Effect&gt;
    &lt;DropShadowEffect BlurRadius="10"
                      Color="Black"
                      Opacity="0.25"
                      Direction="270" /&gt;
  &lt;/UserControl.Effect&gt;

  &lt;Border BorderThickness="0"
          Background="White"&gt;
    &lt;TextBlock Text="Preview loading..."
               HorizontalAlignment="Center"
               VerticalAlignment="Center" /&gt;
  &lt;/Border&gt;
&lt;/UserControl&gt;
</code></pre>

<p>The magic is inside the Loaded event of this control:</p>

<pre><code>private void HtmlPreviewLoaded(object sender, RoutedEventArgs e)
{
    Loaded -= HtmlPreviewLoaded;
    var context = TaskScheduler.FromCurrentSynchronizationContext();

    //We are hosting the Awesomium preview in another appdomain so our main UI thread does not take the hit
    hostAppDomain = AppDomain.CreateDomain("HtmlPreviewDomain");
    var filename = FileName;

    // create the AppDomain on a new thread as we want to ensure it is an 
    // STA thread as this makes life easier for creating UI components
    var thread = new Thread(() =&gt;
    {
        var awesomiumHostType = typeof(AwesomiumHost);
        host = (AwesomiumHost)hostAppDomain.CreateInstanceAndUnwrap(awesomiumHostType.Assembly.FullName, awesomiumHostType.FullName,
        false, BindingFlags.Default, null, new object[] { filename, BaseDirectory }, CultureInfo.CurrentCulture, null);

        host.SetHtml(content);

        var controlHandle = host.ControlHandle;

        Task.Factory.StartNew(() =&gt;
        {
            //Delay until preview control has loaded before creating content host
            host.LoadedWaitHandle.WaitOne();

            // We need to invoke on the Markpad dispatcher, we are currently in the host appdomains STA Thread.
            Dispatcher.BeginInvoke(new Action(() =&gt;
            {
                hwndContentHost = new HwndContentHost(controlHandle);
                //Without the border we don't get the dropshadows
                Content = new Border
                {
                    Background = Brushes.White,
                    Padding = new Thickness(3),
                    Child = hwndContentHost
                };
            }));
        }, TaskCreationOptions.LongRunning);

        host.Run();
        //I can't get this unloading without an error, 
        // I am gathering Application.Shutdown is causing the appdomain to shutdown too
        //AppDomain.Unload(hostAppDomain);
    });

    thread.SetApartmentState(ApartmentState.STA);
    thread.Start();
}
</code></pre>

<p>So what does this actually do!</p>

<p>First we create the AppDomain, and spin up a dedicated thread which will be the UI thread of new AppDomain.</p>

<pre><code>hostAppDomain = AppDomain.CreateDomain("HtmlPreviewDomain");

var thread = new Thread(() =&gt;
{
    // We initialise it all in here
});

thread.SetApartmentState(ApartmentState.STA);
thread.Start();
</code></pre>

<p>Inside this new thread, we create an instance of the AwesomiumHost, which is a class which can be marshalled across AppDomains</p>

<pre><code>public class AwesomiumHost : MarshalByRefObject, IDisposable
{
    public string FileName { get; private set; }
    public string Html { get; set; }
    public double ScrollPercentage { get; set; }

    public IntPtr ControlHandle { get; }
    public ManualResetEvent LoadedWaitHandle { get; }

    public void SetHtml(string content);
    public void WbProcentualZoom();
    public void Print();
    public void Run();

    public void Dispose();
}
</code></pre>

<p>So we create the instance and unwrap it:</p>

<pre><code>var awesomiumHostType = typeof(AwesomiumHost);
host = (AwesomiumHost)hostAppDomain.CreateInstanceAndUnwrap(awesomiumHostType.Assembly.FullName, awesomiumHostType.FullName,
        false, BindingFlags.Default, null, new object[] { filename, BaseDirectory }, CultureInfo.CurrentCulture, null);

host.SetHtml(content);
var controlHandle = host.ControlHandle;
</code></pre>

<p>This has gone and created the control, and got the ControlHandle which we need to host WPF controls across appdomains, there is some nasty code in the <code>static long CreateWindowHandle(Visual frameworkElement)</code> method if you want to know how to do it.</p>

<p>We then start a long running task (background operation in the preview appdomain) which blocks until the control has fully loaded (the LoadedWaitHandle is set once the Loaded event fires on the Awesomium control).</p>

<pre><code>Task.Factory.StartNew(() =&gt;
{
    //Delay until preview control has loaded before creating content host
    host.LoadedWaitHandle.WaitOne();

    // We need to invoke on the Markpad dispatcher, we are currently in the host appdomains STA Thread.
    Dispatcher.BeginInvoke(new Action(() =&gt;
    {
        hwndContentHost = new HwndContentHost(controlHandle);
        //Without the border we don't get the dropshadows
        Content = new Border
        {
            Background = Brushes.White,
            Padding = new Thickness(3),
            Child = hwndContentHost
        };
    }));
}, TaskCreationOptions.LongRunning);
</code></pre>

<p>We then invoke the creation of the content host on Markpads UI thread, and replace the content of the UserControl with the MarkPad preview.</p>

<p>There are a few more things, but this should help you follow the Markpad codebase if you ever want to host a WPF control in another AppDomain :)</p>

<h2>Links</h2>

<p>Go grab the source, have a look. If you are so inclined you can pick up a issue, and submit a pull request!</p>

<p><a href="https://github.com/Code52/DownmarkerWPF">https://github.com/Code52/DownmarkerWPF</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVVM, Design Time vs IoC usage]]></title>
    <link href="http://JakeGinnivan.github.io/wpf-mvvm-thoughs/"/>
    <updated>2011-07-21T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/wpf-mvvm-thoughs</id>
    <content type="html"><![CDATA[<h1>The problems</h1>

<p>Lets start with the problems we want to solve with our solution</p>

<ul>
<li>Blend Design time support</li>
<li>Resharper binding validation support</li>
<li>No using ServiceLocator, DI only</li>
<li>ViewModels should be testable</li>
</ul>


<p>Frameworks like Magellan solve these sort of issues in other ways, but if you don&rsquo;t want to take on a framework then maybe an approach like this may help you get started.</p>

<!-- more -->


<h1>My approach</h1>

<p>I find that once you progress past a basic application with simple interactions that often you need views to interact with each other, this could be returning data from a modal dialogue or anything.</p>

<p>One thing we are often told is we should develop against interfaces, not implementations. I think this applies to views as well, so lets create an IView interface.</p>

<pre><code>public interface IView
{
}
</code></pre>

<p>Now I want to be able to tell the calling viewmodel if I was cancelled, or possibly return data, so we will create three more interfaces and a few classes:</p>

<pre><code>public interface IDialogueView : IView
{
    void DialogueDisplayed();
    void DialogueClosed();
}

public interface IDialogueView&lt;TResult&gt; : IDialogueView
{
    event EventHandler&lt;DialogueResultEventArgs&lt;TResult&gt;&gt; Finished;
}

public interface IDialogueViewWithoutResult : IDialogueView
{
    event EventHandler&lt;DialogueResultEventArgs&gt; Finished;
}

public class DialogueResultEventArgs : EventArgs
{
    public DialogueResultEventArgs(bool cancelled)
    {
        Cancelled = cancelled;
    }

    public bool Cancelled { get; private set; }

    public static DialogueResultEventArgs EmptyResult = new DialogueResultEventArgs(false);
    public static DialogueResultEventArgs CancelledResult = new DialogueResultEventArgs(true);
}

public class DialogueResultEventArgs&lt;T&gt; : EventArgs
{
    public DialogueResultEventArgs(Exception error)
    {
        Result = new DialogueResult&lt;T&gt;(error);
    }

    public DialogueResultEventArgs(T result)
    {
        Result = new DialogueResult&lt;T&gt;(result);
    }

    public static DialogueResultEventArgs&lt;T&gt; Cancelled()
    {
        return new DialogueResultEventArgs&lt;T&gt; { Result = DialogueResult&lt;T&gt;.CancelledResult() };
    }

    private DialogueResultEventArgs() { }

    public DialogueResult&lt;T&gt; Result { get; private set; }
}
</code></pre>

<p>Then we need some way for our ViewModels to interact with other Views using these interfaces, enter IUIService</p>

<pre><code>public interface IUIService
{
    /// &lt;summary&gt;
    /// Shows a view in dialogue mode. The view will return a result. This call is blocking.
    /// &lt;/summary&gt;
    /// &lt;param name="dialogueView"&gt;The dialogue view.&lt;/param&gt;
    DialogueResult&lt;TResult&gt; ShowDialogue&lt;TResult&gt;(IDialogueView&lt;TResult&gt; dialogueView);

    /// &lt;summary&gt;
    /// Shows a view in dialogue mode. No result will be returend. This call is blocking.
    /// &lt;/summary&gt;
    /// &lt;param name="dialogueView"&gt;The dialogue view.&lt;/param&gt;
    DialogueResult ShowDialogue(IDialogueViewWithoutResult dialogueView);
}
</code></pre>

<h2>Creating a new view</h2>

<p>One of our requirements is that we want to support blend, this is pretty easy but I think that the view shells should always be created by the developers. If you have designers, create the empty view for them, wire it up, then hand over to them for them to do their magic. As much as Microsoft has made the developer/designer story much better, you still have to weigh up the pros and cons of trying to get the designers to do too much. Either they learn a basic bit of coding to get a new view setup, or they rely on the devs to create and wire up the empty view.</p>

<p>Start off and create a new &lsquo;WPF Window&rsquo;. Then we define an interface for it in the code behind.</p>

<pre><code>public partial class MyView : IMyView
{
    public MyView(MyViewModel viewModel)
    {
        _viewModel = viewModel;
        DataContext = _viewModel;
        InitializeComponent();
    }

    public void DialogueDisplayed()
    {
        _viewModel.Initialise();
    }

    public void DialogueClosed()
    {
    }

    public event EventHandler&lt;DialogueResultEventArgs&lt;SomeData&gt;&gt; Finished
    {
        add { _viewModel.Finished += value; }
        remove { _viewModel.Finished -= value; }
    }
}

public interface IMyView : IDialogueView&lt;SomeData&gt;
{ }
</code></pre>

<p>Doing this requires some basic coding, but allows full IoC support, and allows the viewmodel to raise the finished event, which will cause the UIService to close the window and return to the caller. It also gives a nice place to hook into things.
In my current projects, we actually define all windows as UserControls, and our UI server creates the window with custom chrome and gives us full control over everything. It is working very well.</p>

<p>Then lets look at the Xaml.</p>

<pre><code>&lt;Window x:Class="WpfApplication3.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        mc:Ignorable="d"
        d:DataContext="{d:DesignInstance MainViewModel, IsDesignTimeCreatable=True}"&gt;
    &lt;Grid&gt;

    &lt;/Grid&gt;
&lt;/Window&gt;
</code></pre>

<p>In my current project we also have an attached behaviour which allows us to specify a provider to set the datacontext. We leave the d:DataContext in there so we get R# support for our bindings =)</p>

<p>Next chance I get, I was thinking that doing something like this in the viewmodel might work quite well.</p>

<h1>IoC &ndash; Putting it together</h1>

<p>In our appliation startup, we need to register out IoC container, I am using Autofac. This is my registration</p>

<pre><code>private void ApplicationStartup(object sender, StartupEventArgs e)
{
    var containerBuilder = new ContainerBuilder();
    containerBuilder.RegisterType&lt;UIService&gt;().As&lt;IUIService&gt;();
    containerBuilder.RegisterType&lt;SomeService&gt;().As&lt;ISomeService&gt;();
    containerBuilder
        .RegisterAssemblyTypes(typeof(App).Assembly)
        .AssignableTo&lt;IView&gt;()
        .AsImplementedInterfaces();
    containerBuilder
        .RegisterAssemblyTypes(typeof(App).Assembly)
        .AssignableTo&lt;ViewModelBase&gt;()
        .AsSelf();
    var container = containerBuilder.Build();
    container.Resolve&lt;IUIService&gt;().ShowDialogue(container.Resolve&lt;IMainView&gt;());
}
</code></pre>

<p>I register my UIService, another random service, then use the assembly scanning features to register viewmodels and views. I then resolve my UIService, and show my IMainViewModel!</p>

<h1>Design Time and Runtime ViewModel wireup</h1>

<p><code>Note:</code> I have not used this technique in a production project, but think it would be cool to try out and think it would be better than the setup I am using now.</p>

<p>We add default constructor to our viewmodel:</p>

<pre><code>public MainWindow() : this(new MainViewModel())
{
}
</code></pre>

<p>We then setup our viewmodel, which will look like:</p>

<pre><code>public class MainViewModel : ViewModelBase
{
    public MainViewModel()
    {
        this.PopulateDesignTimeData().With&lt;MainViewModelData&gt;();
    }

    public MainViewModel(ISomeService someService)
    {
        //To show some DI at runtime
        SomeProperty = someService.GetAValue();
    }

    public string SomeProperty { get; set; }
    public event EventHandler&lt;DialogueResultEventArgs&gt; Finished;

    protected void OnFinished(DialogueResultEventArgs e)
    {
        var handler = Finished;
        if (handler != null) handler(this, e);
    }
}
</code></pre>

<p>Notice in our default contructor we call <code>this.PopulateDesignTimeData().With&lt;MainViewModelData&gt;()</code>? Here is the MainViewModelData class:</p>

<pre><code>public class MainViewModelData : IDesignTimeViewModelPopulator&lt;MainViewModel&gt;
{
    public void Populate(MainViewModel viewModel)
    {
        viewModel.SomeProperty = "blah";
    }
}
</code></pre>

<p>Because of the way our IoC containers work, they will always choose the most specific constructor they can. If it cannot find the dependencies it will default back to the default constructor, which will throw a Debug.Assert because it is not in design time mode.</p>

<h1>Source</h1>

<p><a href="/get/downloads/WpfApplication3.zip">Download example project</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to VSTO Contrib]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-contrib/introduction/"/>
    <updated>2011-04-05T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-contrib/introduction</id>
    <content type="html"><![CDATA[<h1>Goal of VSTO Contrib</h1>

<p>When I first started on this library, it was a very simple set of classes designed to help me do trivial tasks in VSTO, such as simplifying listening to certain events, wrappers, and it was really a dumping ground for code that solved problems I had while developing VSTO solutions.</p>

<p>Just before TechEd last year (August), I started trying to tackle some more fundamental architectural issues, such as no ability to use DI, or IoC, which often causes VSTO solutions to have Ribbons with hundreds of lines of code behind, this issue is made worse with Ribbon XML which only lets you have a single callback file for ALL ribbons.</p>

<!-- more -->


<h1>Version Support</h1>

<p>I am targeting both Office 2007 &amp; 2010 using either .NET 3.5 or .NET 4.0, and currently support Outlook, Word, Excel and PowerPoint. This means there are 16 different packages you can download.</p>

<h1>Features</h1>

<h2>Ribbon Factory</h2>

<p>The Ribbon Factory, apart from needed a better name, is the most compelling feature of VSTO Contrib.</p>

<p>It is a ribbon factory, similar to the one VSTO uses to bring the Ribbon Designer to life (<a href="../vsto-ribbon-designer-in-depth">read more</a>), except mine targets Ribbon XML, and brings all the nice features that the ribbon designer has, like the current context (Contact, Word Document, Powerpoint presentation etc) plus a whole lot more like:</p>

<ul>
<li><p>Creates a new instance of a &lsquo;ViewModel&rsquo; class you define for each context (document etc), and will notify you when the current view changes (multiple windows displaying same document). This view model is managed, and will be cleaned up when the context is closed.</p></li>
<li><p>ViewModels are for a single, or multiple Ribbon types, Word/Excel/PowerPoint are simply the Document, Workbook and Presentation ribbons, but outlook you can create a view model for an AppointmentItems, another viewmodel for ContactItem&rsquo;s, another view model for MailItems</p></li>
<li><p>IoC container support, currently takes a Func&lt;Type, IRibbonViewModel> during initialisation to support custom resolution. I will be creating a IRibbonViewModelFactory at a later stage.</p></li>
<li><p>Synchronised TaskPanes, one of the most common questions on StackOverflow is how do I wire up a button on the ribbon to my custom task pane. It is actually quite hard out of the box, with VSTO Contrib, just inherit from IRegisterCustomTaskPane on your ViewModel and the Ribbon Factory will manage the registration of custom task panes on new windows, and a few other things.</p></li>
<li><p>WPF like binding support, RibbonXML requires you to know the method syntax of all callbacks. You can now go <toggleButton onAction="PanelShown" getPressed="PanelShown" /> where PanelShown is a <strong>property</strong>, it will even listen to PropertyChanged events and invalidate the ribbon control!</p></li>
</ul>


<p>I won&rsquo;t go into detail about how the Ribbon Factory works, and what the code looks like here. But if you would like to read more, I will write all about it at <a href="ribbon-factory">the ribbon factory</a></p>

<h2>Code Driven Click-Once updates</h2>

<p>Due to a different security model, and VSTO having a custom ClickOnce installer if you try and get the Deployment information, then call ApplicationDeployment.Update you can find yourself with a broken add-in.</p>

<p>VSTO Contrib has a helper class to make updating your add-in super easy. Under the covers it is finding the location of the VSTOInstaller.exe, first through registry, then falling back to file system. It then sets up the application trusts needed to make the update process work nicely.</p>

<pre><code>new VstoClickOnceUpdater()
            .CheckForUpdateAsync(
                r =&gt;
                {
                    if (r.Updated)
                    {
                        MessageBox.Show("My awesome add-in was updated");
                    }
                });
</code></pre>

<h2>WPF Integration</h2>

<p>VSTO Contrib has a few helper classes to make WPF development inside VSTO much easier.</p>

<p>Firstly it has a WpfPanelHost, which is registered correctly for COM interop, and works around some issues where WPF controls would not draw correctly until the window is moved.</p>

<p>It also provides a OfficeViewModelBase, and DelegateCommand class to enable easy data binding to your Ribbon View Model.</p>

<h2>COM interop helpers</h2>

<p>One of the things I found really hard when starting VSTO development was learning about the COM interop side of things, and in particularly the &lsquo;right&rsquo; way of doing it, which is why I wrote the blog post on <a href="vsto-com-interop">vsto-com-interop</a>, which explains how the whole COM Interop thing works, any why you should be calling Marshal.ReleaseComObject.</p>

<p>The issue is that code quickly becomes ugly and unmanageable when everything is wrapped in try{} finally{Marshal.ReleaseComObject();}. It also is not tollerant to later versions of Office, which may swap out some of these unmanaged com objects, for managed .net objects. If they do that you will find the call to Marshal.ReleaseComObject throws an exception.</p>

<p>These helpers come in two flavours, simple, and dynamic proxies.</p>

<h3>.WithComCleanup()</h3>

<p>This extension method will return either a <code>Wrapped&lt;ComType&gt; : IDisposable</code> (simple) or a <code>IComType : ComType, IDisposable</code> (dynamic proxy).</p>

<p>Usage is:
<code>using (var sheets = workbook.WorkSheets.WithComCleanup())</code>
<code>sheets.Resource.Add() //for simple</code>
or <code>sheets.Add() //for dynamic proxy version</code></p>

<p>The dynamic proxy is slightly nicer, but you have to take on a dependency to Castle.Core if you want that. If you want to see some more code examples of how this can cleanup your VSTO/Office Automation code, <a href="com-cleanup-extension-methods">have a look here</a></p>

<p>The dynamic proxy version simply removes the need to go .Resource to access the wrapped COM object.</p>

<h3>.ComLinq<T>()</h3>

<p>Allows you to cleanly write linq against office collections. <em>Beware</em> as this will return a IEnumerable<T> with a custom Enumerator which releases the previous item when MoveNext is called. This means it is perfect for code like this:</p>

<pre><code>using (var someSheet = workbook.Sheets.ComLinq&lt;WorkSheet&gt;().Where(s=&gt;s.Name == "Sheet1"))
{ someSheet.Name = "NewSheetName"; }
</code></pre>

<p>But you will get a RCW has been separated from underlying com object exception if you do this:</p>

<pre><code>var sheetOne = workbook.Sheets.ComLinq&lt;WorkSheet&gt;().SingleOrDefault(s=&gt;s.Name == "Sheet1");
sheetOne.Name = "NewSheetName"; //Will throw exception, because Enumerator has already released the WorkSheet as SingleOrDefault forces the IEnumerable to be iterated.
</code></pre>

<p>Future versions may have a custom collection which only expose specific operations to make this extension method more predictable. For the moment, use with caution.</p>

<h3>Outlook User Properties helpers</h3>

<p>You will find some handy extensions called GetPropertyValue<T>, and SetPropertyValue<T>, which are handy wrappers around the UserProperties collection on most outlook items. Has options to automatically create the properties, and specify if they are folder level so they are accessible through search etc. Very handy!</p>

<h2>FolderHomePage [Outlook Only]</h2>

<p>Greatly simplifies the process of creating a custom view for a folder. Ever wanted to select a folder in Outlook, and have a fully blown WPF custom view be displayed, well, this class is for you.</p>

<p>Note: Does need outlook to be running as Administrator, as it registers types for com interop and registers the user controls as safe for scripting, which requires the process to be elevated. I may end up making this an extension which will shell out to a elevated process.</p>

<h2>OutlookFolderMonitor</h2>

<p>Quite a simple class which will monitor an Outlook MAPIFolder for changes, this includes Add/Modified and deleting. Each event has the item being affected, delete is not trivial, which makes this class particularly handy.</p>

<h2>GenericSynchronisationService</h2>

<p>As the name implies, this is a synchronisation helper, which takes care of synchronisation logic, all you have to do is create a source and remote provider. It greatly simplifies your job if you need to synchronise contacts or appointments etc with outlook.</p>

<h1>Where can I get it</h1>

<p>I will be releasing it before MIX 2011 at <a href="http://vstocontrib.codeplex.com/releases">http://vstocontrib.codeplex.com/releases</a></p>

<h1>Feedback</h1>

<p>I would love feedback, I still have a lot of unit testing to do and test every combination of .net and office. Please if you have an issue, let me know!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Taking Screenshots of WPF apps]]></title>
    <link href="http://JakeGinnivan.github.io/wpf-screenshot/"/>
    <updated>2011-02-15T00:00:00+00:00</updated>
    <id>http://JakeGinnivan.github.io/wpf-screenshot</id>
    <content type="html"><![CDATA[<p>In my current project, we have quite an awesome UI automation setup running through every process (happy days path) in our WPF app.</p>

<p>Often we cannot resolve a UI element, and we will get an error like:</p>

<pre><code>White.Core.AutomationException: Failed to get UIElement ControlType=button,AutomationId=OkButton from DialogWindow
</code></pre>

<p>While this is great, often it is hard to figure out why this happens, could be due to a validation error on the previous screen, or a error popup etc. So out infrastructure will automatically take a screenshot whenever it catches a AutomationException.</p>

<p>The problem is the modal window that was often captured (and was blocking a button press on the main window) was coming out as a tiny little square with no contents:</p>

<!-- more -->


<p><img src="/get/screenshots/blankModal.png" alt="Blank Modal Dialogue" /></p>

<p>I began digging, then realised that using GDI+ to take a screenshot of a WPF app doesn&rsquo;t seem to always work. It worked fine on my machine, but not our build machine.</p>

<p>After scouring the internet I put a all the solutions i could find into one big LinqPad script and ran it (this was my original code, so it went first):</p>

<pre><code>var bounds = System.Windows.Forms.Screen.GetBounds(Point.Empty);
var bitmap = new Bitmap(bounds.Width, bounds.Height);
using (var g = Graphics.FromImage(bitmap))
{
    g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
}

bitmap.Dump();
</code></pre>

<p>.Dump() by the way works awesome with Bitmaps as well as everything else under the sun..</p>

<p>The class that ended up working for me is this:</p>

<pre><code>public class ScreenCapture
{
    [DllImport("gdi32.dll")]
    static extern bool BitBlt(IntPtr hdcDest, int xDest, int yDest, int wDest, int hDest, IntPtr hdcSource, int xSrc, int ySrc, CopyPixelOperation rop);
    [DllImport("user32.dll")]
    static extern bool ReleaseDC(IntPtr hWnd, IntPtr hDc);
    [DllImport("gdi32.dll")]
    static extern IntPtr DeleteDC(IntPtr hDc);
    [DllImport("gdi32.dll")]
    static extern IntPtr DeleteObject(IntPtr hDc);
    [DllImport("gdi32.dll")]
    static extern IntPtr CreateCompatibleBitmap(IntPtr hdc, int nWidth, int nHeight);
    [DllImport("gdi32.dll")]
    static extern IntPtr CreateCompatibleDC(IntPtr hdc);
    [DllImport("gdi32.dll")]
    static extern IntPtr SelectObject(IntPtr hdc, IntPtr bmp);
    [DllImport("user32.dll")]
    public static extern IntPtr GetDesktopWindow();
    [DllImport("user32.dll")]
    public static extern IntPtr GetWindowDC(IntPtr ptr);

    public Bitmap CaptureScreenShot()
    {
        var sz = System.Windows.Forms.Screen.PrimaryScreen.Bounds.Size;
        var hDesk = GetDesktopWindow();
        var hSrce = GetWindowDC(hDesk);
        var hDest = CreateCompatibleDC(hSrce);
        var hBmp = CreateCompatibleBitmap(hSrce, sz.Width, sz.Height);
        var hOldBmp = SelectObject(hDest, hBmp);
        BitBlt(hDest, 0, 0, sz.Width, sz.Height, hSrce, 0, 0, CopyPixelOperation.SourceCopy | CopyPixelOperation.CaptureBlt);
        var bmp = Image.FromHbitmap(hBmp);
        SelectObject(hDest, hOldBmp);
        DeleteObject(hBmp);
        DeleteDC(hDest);
        ReleaseDC(hDesk, hSrce);

        return bmp;
    }
}
</code></pre>

<p>And now I have:</p>

<p><img src="/get/screenshots/properModal.png" alt="Working modal screenshot" /></p>
]]></content>
  </entry>
  
</feed>
