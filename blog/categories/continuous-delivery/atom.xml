<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: continuous delivery | Jake Ginnivan's blog]]></title>
  <link href="http://jake.ginnivan.net/blog/categories/continuous-delivery/atom.xml" rel="self"/>
  <link href="http://jake.ginnivan.net/"/>
  <updated>2015-06-08T23:24:51+01:00</updated>
  <id>http://jake.ginnivan.net/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automated Project Environment Setup]]></title>
    <link href="http://jake.ginnivan.net/automated-project-environment-setup/"/>
    <updated>2013-08-08T00:00:00+01:00</updated>
    <id>http://jake.ginnivan.net/automated-project-environment-setup</id>
    <content type="html"><![CDATA[<h2>Web Project Dev Environment</h2>

<p>A common problem projects have is when a new dev joins the team is they hopefully have to follow a bunch of instructions to set everything up. Most of the time, those instructions are out of date so another member of the team ends up setting everything up.</p>

<p>Depending on the complexity of the project, this can be quite time consuming.</p>

<p>The last project I was on was greenfields, so from day 1 we had a <code>Setup Dev Environment.ps1</code> file in the root of the project. This powershell script did the following:</p>

<ul>
<li>Installed IIS, and all the components we needed (windows auth, .net etc)</li>
<li>Registered asp.net with IIS</li>
<li>Created Websites with host headers for each of the sites in the project (we ended up having 3 different websites)</li>
<li>Opened the HOSTS file in notepad (elevated) and printed out the lines you needed to paste into your HOSTS file</li>
</ul>


<p>Over time, this script gained more and more features. But when a new team member joined the team, they just ran this script which installed/configured everything.</p>

<p>Why IIS you may ask, instead of say IIS Express. Well this approach means each site had it&rsquo;s own domain, so fiddler works out of the box. It also means that our UI Test suite doesn&rsquo;t have to fire up IIS Express to run it&rsquo;s tests.</p>

<!-- more -->


<h3>The script</h3>

<p>This is what our script looked like</p>

<pre><code>&amp; DISM /Online /Enable-Feature /All `
/FeatureName:IIS-ApplicationDevelopment `
/FeatureName:IIS-ASPNET `
/FeatureName:IIS-BasicAuthentication `
/FeatureName:IIS-CommonHttpFeatures `
/FeatureName:IIS-DefaultDocument `
/FeatureName:IIS-DirectoryBrowsing `
/FeatureName:IIS-HttpErrors `
/FeatureName:IIS-HttpLogging `
/FeatureName:IIS-HttpRedirect `
/FeatureName:IIS-HttpTracing `
/FeatureName:IIS-ISAPIFilter `
/FeatureName:IIS-ISAPIExtensions `
/FeatureName:IIS-IIS6ManagementCompatibility `
/FeatureName:IIS-ManagementConsole `
/FeatureName:IIS-ManagementScriptingTools `
/FeatureName:IIS-Metabase `
/FeatureName:IIS-NetFxExtensibility `
/FeatureName:IIS-ASPNET45 `
/FeatureName:IIS-NetFxExtensibility45 `
/FeatureName:NetFx4Extended-ASPNET45 `
/FeatureName:IIS-Security `
/FeatureName:IIS-ServerSideIncludes `
/FeatureName:IIS-StaticContent `
/FeatureName:IIS-WebServer `
/FeatureName:IIS-WebServerManagementTools `
/FeatureName:IIS-WebServerRole `
/FeatureName:IIS-WindowsAuthentication `
/FeatureName:IIS-WMICompatibility `
/FeatureName:WAS-ConfigurationAPI `
/FeatureName:WAS-NetFxEnvironment `
/FeatureName:WAS-ProcessModel `
/FeatureName:WAS-WindowsActivationService

&amp; C:\Windows\Microsoft.NET\Framework\v4.0.30319\aspnet_regiis.exe -i

$invocation = (Get-Variable MyInvocation).Value
$directorypath = Split-Path $invocation.MyCommand.Path
$physicalPath = Join-Path $directorypath "src\SampleWebSite"
$adminWebPhysicalPath = Join-Path $directorypath "src\Project.AdminWeb"
$guestServicesPhysicalPath = Join-Path $directorypath "src\Project.GuestServices"
$fakeApiPhysicalPath = Join-Path $directorypath "src\FakeSiteApi"
$elevate = Join-Path $directorypath "tools\Elevate.exe"

&amp; c:\Windows\system32\inetsrv\AppCmd.exe add apppool /name:SampleWebSiteAppPool /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set config /section:applicationPools "/[name='SampleWebSiteAppPool'].processModel.identityType:LocalSystem"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe add site /name:SampleWebSite /physicalPath:$physicalPath /bindings:http/*:80:samplewebsite.net
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set app "SampleWebSite/" /applicationPool:"SampleWebSiteAppPool"

&amp; c:\Windows\system32\inetsrv\AppCmd.exe add apppool /name:AdminSiteAppPool /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set config /section:applicationPools "/[name='AdminWebAppPool'].processModel.identityType:LocalSystem"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe add site /name:"AdminSite" /physicalpath:"$adminWebPhysicalPath" /bindings:http/*:80:adminsite.net
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set app "AdminSite/" /applicationPool:"AdminSiteAppPool"

&amp; c:\Windows\system32\inetsrv\AppCmd.exe add apppool /name:GuestServicesAppPool /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set config /section:applicationPools "/[name='GuestServicesAppPool'].processModel.identityType:LocalSystem"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe add site /name:"GuestServices" /physicalPath:$guestServicesPhysicalPath /bindings:http/*:80:guestservices.net
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set app "GuestServices/" /applicationPool:"GuestServicesAppPool"

&amp; c:\Windows\system32\inetsrv\AppCmd.exe add apppool /name:FakeApiAppPool /managedRuntimeVersion:v4.0 /managedPipelineMode:Integrated
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set config /section:applicationPools "/[name='FakeEmbedApiAppPool'].processModel.identityType:LocalSystem"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe add site /name:"FakeApi" /physicalPath:$fakeEmbedApiPhysicalPath /bindings:http/*:80:siteapi.net
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set app "FakeApi/" /applicationPool:"FakeApiAppPool"

Write-Host "Add the following lines to your hosts file:" -ForegroundColor red
Write-Host "127.0.0.1      samplewebsite.net" -ForegroundColor yellow
Write-Host "127.0.0.1      adminsite.net" -ForegroundColor yellow
Write-Host "127.0.0.1      guestservices.net" -ForegroundColor yellow
Write-Host "127.0.0.1      siteapi.net" -ForegroundColor yellow
Write-Host ""

Start-Process $elevate -ArgumentList "notepad c:\Windows\system32\drivers\etc\hosts"
</code></pre>

<p>You can also put unattended installs for SQL, or any other dependencies your project has.</p>

<h2>Build Server considerations</h2>

<p>We also were running UI Tests using <a href="http://teststack.net/TestStack.Seleno/">http://teststack.net/TestStack.Seleno/</a></p>

<p>This meant we needed our build server setup to be able to run the project, as well as build it. The great thing about this script, is you can reuse it to set up your build server.</p>

<p>For the build server, we had another script, which would re-map the IIS sites to the correct folder (as teamcity can checkout your code to different folders, we didn&rsquo;t want to set things up over and over).</p>

<p>The script looked like this</p>

<pre><code>$invocation = (Get-Variable MyInvocation).Value
$directorypath = Split-Path $invocation.MyCommand.Path
$physicalPath = Join-Path $directorypath "src\SampleWebSite"
$adminWebPhysicalPath = Join-Path $directorypath "src\AdminWeb"
$guestServicesPhysicalPath = Join-Path $directorypath "src\GuestServices"
$fakeApiPhysicalPath = Join-Path $directorypath "src\FakeApi"
$elevate = Join-Path $directorypath "tools\Elevate.exe"

&amp; c:\Windows\system32\inetsrv\AppCmd.exe set vdir "SampleWebSite/" /physicalPath:"$physicalPath"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set vdir "AdminSite/" /physicalpath:"$adminWebPhysicalPath"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set vdir "GuestServices/" /physicalpath:"$guestServicesPhysicalPath"
&amp; c:\Windows\system32\inetsrv\AppCmd.exe set vdir "FakeApi/" /physicalpath:"$fakeApiPhysicalPath"
</code></pre>

<p>Just execute this as part of your build process before you run your UI Automation tests.</p>

<h2>Wrapping up</h2>

<p>I encourage you to create your own SetupEnvironment.ps1 script on the project you are on at the moment, it will be well worth the time investment over the lifetime of the project (we found it had saved us time within a few weeks).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ClickOnce Deployment in TeamCity]]></title>
    <link href="http://jake.ginnivan.net/clickonce-deployment-in-teamcity/"/>
    <updated>2009-08-29T00:00:00+01:00</updated>
    <id>http://jake.ginnivan.net/clickonce-deployment-in-teamcity</id>
    <content type="html"><![CDATA[<p>I have been trying to get a ClickOnce VSTO add-in publishing automatically during a build and do not want visual studio on my build server.</p>

<p>This blog post was very useful for getting the initial build working <a href="http://abdullin.com/journal/2009/2/17/building-vsto-solutions-without-visual-studio.html">http://abdullin.com/journal/2009/2/17/building-vsto-solutions-without-visual-studio.html</a> it also mentions how to fix the error MSB3147: Could not find required file &lsquo;setup.bin&rsquo; in &lsquo;ProjectFolder\Engine&rsquo; error I was getting.</p>

<p>According to the post we just have to copy the Generic Bootstrapper across to our build machine and create a registry key to let .net know where to find it.</p>

<p>What all the resources (I have seen the same fix posted in a lot of places) fail to mention is the registry key that you need to modify if you are running a x64 system is HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\GenericBootstrapper\3.5.</p>

<p>This Wow6432Node key has got me a few times before…</p>
]]></content>
  </entry>
  
</feed>
