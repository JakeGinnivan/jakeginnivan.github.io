<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Async | Jake Ginnivan's blog]]></title>
  <link href="http://jake.ginnivan.net/blog/categories/async/atom.xml" rel="self"/>
  <link href="http://jake.ginnivan.net/"/>
  <updated>2014-01-08T22:01:19+00:00</updated>
  <id>http://jake.ginnivan.net/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Awaitable DelegateCommand]]></title>
    <link href="http://jake.ginnivan.net/awaitable-delegatecommand/"/>
    <updated>2013-03-15T00:00:00+00:00</updated>
    <id>http://jake.ginnivan.net/awaitable-delegatecommand</id>
    <content type="html"><![CDATA[<p>Most of you would be aware of DelegateCommand, it allows you to turn a lambda (or two if you want to specify canexecute) into a WPF ICommand.</p>

<p>This is pretty easy to unit test as well, you can simply go <code>viewModel.MyCommand.Execute(null)</code></p>

<p>But this falls down when you start using async, because the lambda will end up being an <strong>async void</strong> method. This means your test can no longer observe what happens in that command. If the implementation throws, your unit test will not know about it and then your test process will crash (if using .net 4.0).</p>

<p>Read <a href="http://blogs.msdn.com/b/lucian/archive/2013/02/18/talk-the-new-async-design-patterns.aspx">Lucians blog post</a> for more information about why async void is bad.</p>

<p>So we introduced a new interface, called <code>IAsyncCommand</code> and it looks like this</p>

<!-- more -->


<pre><code>public interface IAsyncCommand : IAsyncCommand&lt;object&gt;
{
}

public interface IAsyncCommand&lt;in T&gt; : IRaiseCanExecuteChanged
{
    Task ExecuteAsync(T obj);
    bool CanExecute(object obj);
    ICommand Command { get; }
}
</code></pre>

<p>If you were wondering what IRaiseCanExecuteChanged is, it is a really simply interface which means we don&rsquo;t have to cast ICommands. See this <a href="https://gist.github.com/JakeGinnivan/5166866">Gist</a> for the code for that.</p>

<p>You might notice that there is no <code>void Execute(object obj)</code> method on the command, this is to make it impossible to call the async void overload in your unit tests, unless you get the underlying ICommand from the Command property.</p>

<h1>So how does WPF execute the command?</h1>

<p>WPF actually doesnt care about what is exposed via the API, as long as the class implements ICommand, we are good. Introducing AwaitableDelegateCommand:</p>

<pre><code>public class AwaitableDelegateCommand : AwaitableDelegateCommand&lt;object&gt;, IAsyncCommand
{
    public AwaitableDelegateCommand(Func&lt;Task&gt; executeMethod) 
        : base(o=&gt;executeMethod())
    {
    }

    public AwaitableDelegateCommand(Func&lt;Task&gt; executeMethod, Func&lt;bool&gt; canExecuteMethod) 
        : base(o=&gt;executeMethod(), o=&gt;canExecuteMethod())
    {
    }
}

public class AwaitableDelegateCommand&lt;T&gt; : IAsyncCommand&lt;T&gt;, ICommand
{
    private readonly Func&lt;T, Task&gt; _executeMethod;
    private readonly DelegateCommand&lt;T&gt; _underlyingCommand;
    private bool _isExecuting;

    public AwaitableDelegateCommand(Func&lt;T, Task&gt; executeMethod)
        : this(executeMethod, _ =&gt; true)
    {
    }

    public AwaitableDelegateCommand(Func&lt;T, Task&gt; executeMethod, Func&lt;T, bool&gt; canExecuteMethod)
    {
        _executeMethod = executeMethod;
        _underlyingCommand = new DelegateCommand&lt;T&gt;(x =&gt; { }, canExecuteMethod);
    }

    public async Task ExecuteAsync(T obj)
    {
        try
        {
            _isExecuting = true;
            RaiseCanExecuteChanged();
            await _executeMethod(obj);
        }
        finally
        {
            _isExecuting = false;
            RaiseCanExecuteChanged();
        }
    }

    public ICommand Command { get { return this; } }

    public bool CanExecute(object parameter)
    {
        return !_isExecuting &amp;&amp; _underlyingCommand.CanExecute((T)parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { _underlyingCommand.CanExecuteChanged += value; }
        remove { _underlyingCommand.CanExecuteChanged -= value; }
    }

    public async void Execute(object parameter)
    {
        await ExecuteAsync((T)parameter);
    }

    public void RaiseCanExecuteChanged()
    {
        _underlyingCommand.RaiseCanExecuteChanged();
    }
}
</code></pre>

<p>Notice that the AwaitableDelegateCommand implements ICommand, which makes WPF happy, but our viewmodels expose IAsyncCommand, which makes our tests happy. All in all, it works pretty well for me!</p>

<p>If you need a <code>DelegateCommand</code> implementation, check out <a href="https://gist.github.com/JakeGinnivan/5166898">this gist</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async warning with nSubstitute]]></title>
    <link href="http://jake.ginnivan.net/async-warning-with-nsubstitute/"/>
    <updated>2012-10-16T00:00:00+01:00</updated>
    <id>http://jake.ginnivan.net/async-warning-with-nsubstitute</id>
    <content type="html"><![CDATA[<p>I got sick of a heap of warnings in VS which look like this:</p>

<pre><code>Warning 1   Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.
</code></pre>

<p>The code which was causing this error was a received call: <code>_service.Received().CancelAsync()</code></p>

<p>My solution to the problem is creating a simple extension</p>

<pre><code>public static class NSubstituteHelper
{
    public static void IgnoreAwaitForNSubstituteAssertion(this Task task)
    {

    }
}
</code></pre>

<p>Then my code turns into <code>_service.Received().CancelAsync().IgnoreAwaitForNSubstituteAssertion()</code> and my issue goes away</p>
]]></content>
  </entry>
  
</feed>
