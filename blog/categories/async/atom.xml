<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: async | Jake Ginnivan's blog]]></title>
  <link href="http://jake.ginnivan.net/blog/categories/async/atom.xml" rel="self"/>
  <link href="http://jake.ginnivan.net/"/>
  <updated>2015-07-28T11:48:07+08:00</updated>
  <id>http://jake.ginnivan.net/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[nUnit 2.6.3, async and .net 4.0 broken]]></title>
    <link href="http://jake.ginnivan.net/blog/2014/01/15/nunit-263-async-and-dotnet40-broken/"/>
    <updated>2014-01-15T02:55:09+08:00</updated>
    <id>http://jake.ginnivan.net/blog/2014/01/15/nunit-263-async-and-dotnet40-broken</id>
    <content type="html"><![CDATA[<p>I am currently working on a <strong>.net 4.0</strong> project which uses async/await quite heavily. We also are using the old AsyncTargeting pack rather than the RTM because we do not have stats on how many clients currently have the <a href="http://www.microsoft.com/en-us/download/details.aspx?id=3556">.net 4.0 KB 2468871 patch</a> which enables PCL support. These issues affect the RTM version as well.</p>

<p>Recently I have upgraded to nCrunch 2.2 beta and ReSharper 8.1 both which ship with the upgraded nUnit 2.6.3 runner. After I upgraded these tools I noticed tests which should have been failing were passing and passing tests were being reported as failing but showing stack traces from a different test..</p>

<p>Also I was getting different results in nCrunch, R# and nUnits console runner. Something was broken.</p>

<p><strong>NOTE</strong>: Async and TPL support is <em>not supported</em> in nUnit 2.x, but will be officially supported in v3.x and that it was a coincidence that it worked in 2.6.2. My discussions about the issues are at <a href="https://groups.google.com/forum/#!topic/nunit-discuss/McE95Cy2DlY">here on the nunit discussion board</a>.<br/>
As far as I can tell, there is no reason that 4.0 cannot be supported because to offer framework support does not need any new features OR the classes in the Async Targeting Pack or .NET 4.5. At a minimum tests returning <code>Task</code> should be supported as TPL was introduced into the CLR for net40.  <br/>
Recently I added async void and Task support to <a href="https://github.com/TestStack/TestStack.BDDfy/pull/32">BDDfy</a> which targets .NET 4.0, also xUnit 1.9.x supports Tasks in the current released version and has backported <code>async void</code> support to the 1.9.x codebase from the 2.0 and will be released if there is a need to release another patch release before 2.0 is released.</p>

<p><strong>.NET 4.5 is fully supported and works as expected with nUnit, it is only .net 4.0 which is affected</strong></p>

<!-- more -->


<p><img src="/assets/posts/2014-01-14-nunit-263,asyncandnet4.png" alt="2014-01-14-nunit-263,asyncandnet4" /></p>

<p>When I first saw this it really really confused me, so I have been diving into async, nUnit and trying all different things which is where my blog post on <a href="http://jake.ginnivan.net/blog/2014/01/10/on-async-and-sync-contexts/">async and synchronisation contexts</a> came from.</p>

<h2>So what&rsquo;s broken?</h2>

<p>But in 2.6.3 tests returning <code>Task</code> and <code>async void</code> tests will not wait for completion. In addition to that, nUnit 2.6.3 will flat out refuse to run tests which return <code>Task</code> and the console runner will return an error code. Other runners just silently skip the tests&hellip;</p>

<p>This means that if you use async/await <em>or</em> TPL and have upgraded to R# 8.1, nCrunch 2.2 or 2.3 beta, the nUnit.Runners NuGet project or any other tools which have upgraded to use the nUnit 2.6.3 runner internally your async tests will be completing <strong>unobserved</strong> and may be failing without your knowledge.</p>

<h3>Repro Solution</h3>

<p>I put together a sample solution showing the issues (and the screenshot above is from) the GitHub repo is available at <a href="https://github.com/JakeGinnivan/nUnit_net4.0AsyncIssues">https://github.com/JakeGinnivan/nUnit_net4.0AsyncIssues</a></p>

<p>Here are the test results from 2.6.2:</p>

<pre><code>Tests run: 3, Errors: 1, Failures: 0, Inconclusive: 0, Time: 1.4863562 seconds
  Not run: 0, Invalid: 0, Ignored: 0, Skipped: 0

Errors and Failures:
1) Test Error : ClassLibrary1.Class1Tests.Test1
   System.InvalidOperationException : Operation is not valid due to the current state of the object.

Server stack trace:
   at ClassLibrary1.Class1Tests.&lt;Test1&gt;d__0.MoveNext() in c:\Users\Jake\_Code\WpfApplication4\ClassLibrary1\Class1Tests.cs:line 19

Exception rethrown at [0]:
   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.&lt;ThrowAsync&gt;b__0(Object state)
   at NUnit.Core.AsyncSynchronizationContext.AsyncOperationQueue.InvokePendingOperations()
   at NUnit.Core.AsyncSynchronizationContext.AsyncOperationQueue.InvokeAll()
   at NUnit.Core.NUnitAsyncTestMethod.RunVoidAsyncMethod(TestResult testResult)
</code></pre>

<p>And 2.6.3:</p>

<pre><code>Tests run: 2, Errors: 0, Failures: 0, Inconclusive: 0, Time: 0.676135209417321 seconds
  Not run: 1, Invalid: 1, Ignored: 0, Skipped: 0

Errors and Failures:

Tests Not Run:
1) NotRunnable : ClassLibrary1.Class1Tests.Test3
   Test method has non-void return type, but no result is expected
</code></pre>

<h2>What to do about it</h2>

<p>Luckily we can fix this and go back to a working version of nUnit (which as far as I can tell works perfectly for both <code>async void</code> and <code>Task</code> tests).</p>

<p>First you will need to <a href="http://launchpad.net/nunitv2/trunk/2.6.2/+download/NUnit-2.6.2.zip">download nUnit 2.6.2</a> and extract it to a known location</p>

<h3>Fixing ReSharper</h3>

<p>ReSharper is pretty easy as the options dialog allows you to override the runner it uses.</p>

<p>Go into the Resharper menu, then Options. Scroll down to <em>Unit Testing</em> under tools and select NUnit.</p>

<p>Then you can point ReSharper at the nUnit lib directory like so:
<img src="/assets/posts/2014-01-14-nunit-263,asyncandnet41.png" alt="2014-01-14-nunit-263,asyncandnet41" /></p>

<p>Now ReSharper will be using a non-broken version of nUnit.</p>

<h3>Fixing nCrunch</h3>

<p>nCrunch is a little harder, but this fix works fine.</p>

<p>First open up <code>C:\Program Files (x86)\Microsoft Visual Studio 12.0\Common7\IDE\Extensions\Remco Software\NCrunch for Visual Studio 2013</code>, then overwrite <code>nunit.core.dll</code> and <code>nunit.core.interfaces.dll</code> with the ones from the 2.6.2 zip you downloaded earlier.</p>

<p>Now nCrunch will be using the non-broken version. Yay</p>

<h2>Summary</h2>

<p>If you are using .NET 4.0, async/await <em>or</em> TPL and nUnit, do not upgrade your runners to 2.6.3 and if any tools/build servers you are using upgrade, make sure you set them back to using 2.6.2 manually</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On Async and Sync Contexts]]></title>
    <link href="http://jake.ginnivan.net/blog/2014/01/10/on-async-and-sync-contexts/"/>
    <updated>2014-01-10T22:12:49+08:00</updated>
    <id>http://jake.ginnivan.net/blog/2014/01/10/on-async-and-sync-contexts</id>
    <content type="html"><![CDATA[<p>This week has been a really heavy learning experience for me in terms of async/await, .ConfigureAwait() and how it interacts with Synchronisation Contexts. Quite a few of my assumptions were wrong, or the behaviour is different between the .NET 4.0 implementation (CTP3 and RTM) and what happens in .NET 4.5.</p>

<p>In this post I will cover:</p>

<ul>
<li>What .ConfigureAwait(false) does in .net 4.0 and in .net 4.5, and why they act differently</li>
<li>Some guidance around using await in a rich client app (i.e await for <em>offloading</em>, not scalability) .net 4.0 in particular, .net 4.5 behaves better and the guidance is not as relevant</li>
<li>How you can use custom awaiters to switch contexts</li>
</ul>


<!-- more -->


<h2>Quick SynchronizationContext Intro</h2>

<p>If you do not know what synchronization context&rsquo;s are, then I will quickly cover them here. If you know what they do, skip to the next section.</p>

<p>A SynchronizationContext allows you to queue a unit of work on another <em>context</em>, a context can be a specific thread or it may be shared between multiple threads. For example you can get the SynchronizationContext of the current thread by going <code>var uiSyncContext = SynchronizationContext.Current</code>, you can use it to run a delegate on the UI thread (or whatever context the SynchronizationContext represents) with <code>uiSyncContext.Send(state =&gt; { MyProperty = state; }, state: "bar")</code>. This will pass the string &ldquo;bar&rdquo; through as state (without implicitly capturing the outside closure) then assign to MyProperty on the UI thread.</p>

<p>SynchronizationContext&rsquo;s also get notified when asynchronous work is started, which is how frameworks like (<a href="http://www.nunit.org/">nUnit</a>, <a href="http://xunit.codeplex.com/">xUnit 2.0</a>, <a href="https://github.com/TestStack/TestStack.BDDfy">BDDfy</a> and others supports tests which have a method signature of <code>async void</code></p>

<h2>How await uses SynchronisationContext&rsquo;s</h2>

<p>Async/await is just compiler magic to make it easier to compose asynchronous stuff, it does not make your code run asynchronously all it does is when it sees an await, it splits your method up into a state machine then when the thing you are awaiting finishes executing, the state machine is resumed and your code continues running. Resuming execution is called the <em>continuation</em>.<br/>
A great feature of the <code>await</code> keyword is that it captures the current SynchronizationContext before it runs the asynchronous operation, then it will post the continuation to that SynchronizationContext, meaning if you are on the UI Thread when you <code>await Foo()</code> once <code>Foo()</code> finishes running your code will continue execution on the UI Thread.</p>

<p>This scenario here is called <em>offloading</em>, because the UI thread is an important thread you want to run as little code as possible on the UI thread.</p>

<h3>Controlling await with .ConfigureAwait()</h3>

<p>To change the default behaviour TPL gives us the <code>.ConfigureAwait(bool continueOnCapturedContext)</code>, this allows you to write code like this:</p>

<pre><code>public async Task&lt;ObservableCollection&lt;DataViewModel&gt;&gt; DoSomeStuff() {
    var results = await _service.GetSomeData().ConfigureAwait(false);
    var mappedData = MapDataToViewModels(results); // Just pretend this is CPU bound work
    return mappedData;
}
</code></pre>

<p>Because of the <code>.ConfigureAwait(false)</code> our continuation and the <code>MapDataToViewModels()</code> method call will be run on a background thread (unless the awaited task is already complete, then the continuation will be executed in-line). Lets take this one step further</p>

<pre><code>public async Task&lt;ObservableCollection&lt;DataViewModel&gt;&gt; DoSomeStuff() {
    var results = await _service.GetSomeData().ConfigureAwait(false);
    var mappedData = MapDataToViewModels(results);
    var moreData = await _service.GetMoreData();
    UpdateViewModelsWithAdditionalData(moreData);
    return mappedData;
}
</code></pre>

<p>In which context does <code>UpdateViewModelsWithAdditionalData(moreData);</code> run?</p>

<p>The answer is <em>it depends</em>, on .net 4.0 <code>UpdateViewModelsWithAdditionalData(moreData);</code> runs on the UI thread, on .net 4.5 it will run on the <em>threadpool</em>. Why is this? To answer that we need to dive into something called the execution context.</p>

<h3>Execution Context?</h3>

<p>When our .NET code is executing, these is a bunch of additional metadata which floats around with our thread, these are things like security information and the synchronisation context. For more in depth information on the .net execution context have a read of <a href="http://blogs.msdn.com/b/pfxteam/archive/2012/06/15/executioncontext-vs-synchronizationcontext.aspx">http://blogs.msdn.com/b/pfxteam/archive/2012/06/15/executioncontext-vs-synchronizationcontext.aspx</a>.</p>

<p>The important thing to know about the execution context is that the .NET framework flows it around so things work as we would expect, for instance if we start a new thread, out execution context will go with us. Task.Run, ThreadPool.QueueUserWorkItem() etc all will flow the execution context (but will supress the flow of the SynchronizationContext).</p>

<h2>Differences between .NET 4.0 and 4.5</h2>

<p>So we have explained some of the moving parts when we are dealing with async/await. (If you would like me to do a more in depth post on async/await in general and how it works starting from the basics, leave a comment below).</p>

<p>Above I showed this code</p>

<pre><code>public async Task&lt;ObservableCollection&lt;DataViewModel&gt;&gt; DoSomeStuff() {
    var results = await _service.GetSomeData().ConfigureAwait(false);
    var mappedData = MapDataToViewModels(results);
    var moreData = await _service.GetMoreData();
    UpdateViewModelsWithAdditionalData(moreData);
    return mappedData;
}
</code></pre>

<p>And said that in .NET 4.0 <code>UpdateViewModelsWithAdditionalData(moreData);</code> would run on the UI thread and in .NET 4.5 it would run on the ThreadPool. This is because of how the different implementations capture the <code>ExecutionContext</code>.</p>

<h3>Breakdown of .NET 4.0</h3>

<p>If we break this method down into what will be executed. This is a mixture of the generated state machine, library code and code to just demonstrate what is happening (because there are heaps of moving parts).</p>

<pre><code>int state;
Results results;

void IAsyncStateMachine.MoveNext()
{
    switch 1:
        var mappedData = MapDataToViewModels(results);
        // etc...
        break;
    // etc...
    default:
        var ex = ExecutionContext.Capture();
        var task = _service.GetSomeData();

        TaskAwaiter.OnCompletedInternal(task, ()=&gt; {
            ex.Run(()=&gt;
            {
                results = task.Result;
                state = 1;
                MoveNext();
            });
        }, continueOnCapturedContext: false);
}
</code></pre>

<p>Now there are a few things to look at in this small bit of code, first is <code>var ex = ExecutionContext.Capture();</code>, this captures the current execution context and the ExecutionContext contains the SynchronizationContext so when we execute <code>MoveNext()</code> our SynchronizationContext has been restored BUT because the TaskAwaiter.OnCompletedInternal has been told to not continue on the captured context it will be run on the default task scheduler.</p>

<p>The end result of all this is when <code>var mappedData = MapDataToViewModels(results);</code> runs we will:</p>

<ul>
<li>Be running on the ThreadPool</li>
<li>SynchronizationContext.Current will still be the <code>DispatcherSynchronizationContext</code></li>
</ul>


<p>So on the next line when we await and <em>do not use</em> .ConfigureAwait(false) the continuation will run on the captured SynchronizationContext</p>

<h3>.NET 4.5 Behaviour</h3>

<p>Lets have a look at what the code looks like in .NET 4.5 land.</p>

<pre><code>int state;
Results results;

void IAsyncStateMachine.MoveNext()
{
    switch 1:
        var mappedData = MapDataToViewModels(results);
        // etc...
        break;
    // etc...
    default:
        var ex = ExecutionContext.CaptureInternal(ExecutionContext.CaptureOptions.IgnoreSyncCtx); 
        var task = _service.GetSomeData();

        TaskAwaiter.OnCompletedInternal(task, ()=&gt; {
            ex.Run(()=&gt;
            {
                results = task.Result;
                state = 1;
                MoveNext();
            });
        }, continueOnCapturedContext: false);
}
</code></pre>

<p>Notice the line where the execution context is captured, in .NET 4.5 the AsyncMethodBuilderCore calls an <em>internal</em> method on the ExecutionContext which allows the caller to specify that they do not want the SynchronizationContext to be captured as part of the ExecutionContext.</p>

<p>The reason .NET 4.0 and .NET 4.5 are different is that this internal cannot be called from the Async Targeting Pack because it&rsquo;s a library, in .NET 4.5 the AsyncMethodBuilderCore is part of the framework so it can call this internal methods.</p>

<h3>How does TaskEx.Run not capture SynchronizationContext?</h3>

<p>Because TaskEx.Run delegates to <code>Task.Factory.StartNew()</code> which is part of the framework, it passes the option to not capture the SynchronizationContext</p>

<h2>Some guidance for .NET 4.0</h2>

<p>The general guidance is any library code should use <code>.ConfigureAwait(false)</code> so our continuations do not constantly post back to the UI thread, because .NET 4.0 always flows the SynchronizationContext it means that <em>all</em> of our await calls should have <code>.ConfigureAwait(false)</code> which is pretty ugly. Also because .ConfigureAwait(false) still checks if the task is complete, using <code>.ConfigureAwait(false)</code> does not guarantee that we will no longer be executing on the UI thread.</p>

<p>Rather than using .ConfigureAwait() we can explicitly get our code running on the ThreadPool as soon as possible. There are two options for this (that I can see currently):</p>

<p>In ViewModels when you invoke any sort of async service, wrap it in a <code>await TaskEx.Run(()=&gt;_myService.DoStuffAsync());</code>, this is quite good because if your service calls other services you do not get the problem where all your services have <code>TaskEx.Run</code> scattered everywhere and you are scheduling a heap more things into the ThreadPool.</p>

<p>Create a app services layer which your viewmodels interact with, in this layer you delegate to your domain or existing app services, but wrap it in a <code>TaskEx.Run(()=&gt;..);</code></p>

<pre><code>| UI/ViewModels |   ==&gt;   | Service Layer (TaskEx.Run) |   ==&gt;   | Rest of app (never has sync context) |
</code></pre>

<p>Both of these options basically try and make sure that only code executing in the ViewModels have a SynchronizationContext, and the rest of your application had no threading concerns.</p>

<h3>Additional Option for .NET 4.5</h3>

<p>If you are using .NET 4.5, then another option is to create a custom awaiter (<em>note</em> this feature was removed from the async CTP, possibly because it doesn&rsquo;t work properly in .NET 4.0 and also because it can confuse people)</p>

<pre><code>await TaskHelper.SwitchToThreadPool();
</code></pre>

<p>Just awaiting this will cause our async method to switch onto the ThreadPool, personally I think this is quite nice because you do not have to pay the Lambda Tax of <code>Task.Run(..)</code></p>

<p>The code is pretty simple</p>

<pre><code>public static class TaskHelper
{
    public static SwitchContextToThreadPoolAwaiter SwitchToThreadPool()
    {
        return new SwitchContextToThreadPoolAwaiter();
    }
}

public struct SwitchContextToThreadPoolAwaiter : INotifyCompletion
{
    public SwitchContextToThreadPoolAwaiter GetAwaiter() { return this; }

    public bool IsCompleted { get { return false; } }

    public void OnCompleted(Action continuation)
    {
        if (!Thread.CurrentThread.IsThreadPoolThread)
            ThreadPool.QueueUserWorkItem(state =&gt; ((Action)state)(), continuation);
        else
            continuation();
    }

    public void GetResult() { }
}
</code></pre>

<h2>Summary</h2>

<p>I dived into this because of randomly failing tests when I upgraded to nCrunch 2.2 beta, this was due to some false assumptions about how async/await worked in .net 4.0 and also because of some <em>helper</em> classes which scheduled work on the threadpool or on the main UI thread.
Because of the way the SyncContext flowed, the nUnit synchronisation context was present where we thought it should not be. Because of this our code and helpers were not working correctly as the WPF UI DispatcherSynchronizationContext can be captured as a TaskScheduler and has a few other differences.</p>

<p>In short</p>

<ul>
<li>.NET 4.0 flows the SynchronizationContext always, even when you use <code>.ConfigureAwait(false)</code></li>
<li>.NET 4.5 does not flow the SynchronizationContext when you use <code>.ConfigureAwait(false)</code></li>
<li>Don&rsquo;t try and use the nUnit SynchronizationContext as a task scheduler</li>
<li>If you are using .NET 4.0, use TaskEx.Run to get off the UI Thread as fast as possible, then use an <code>await</code> in your viewmodel to capture the UI thread and bring you back to it</li>
<li>Make sure your application code does not need to run on the UI thread, if you have services (like say an <code>IDialogService</code>) then it should post to the UI dispatcher in that service so it is effectively mocked in your unit tests. This was the main source of our issues with tests failing..</li>
<li>Don&rsquo;t mix threading concerns and application code</li>
</ul>


<p>I Hope that helps a few people understand SynchronizationContexts, ExecutionContexts and how async/await works with either of them.</p>

<h2>Resources</h2>

<p><a href="http://blogs.msdn.com/b/pfxteam/archive/2012/06/15/executioncontext-vs-synchronizationcontext.aspx">Stephen Toub on ExecutionContext vs SynchronizationContext (talks about .net 4.5 behaviour)</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Awaitable DelegateCommand]]></title>
    <link href="http://jake.ginnivan.net/awaitable-delegatecommand/"/>
    <updated>2013-03-15T00:00:00+08:00</updated>
    <id>http://jake.ginnivan.net/awaitable-delegatecommand</id>
    <content type="html"><![CDATA[<p>Most of you would be aware of DelegateCommand, it allows you to turn a lambda (or two if you want to specify canexecute) into a WPF ICommand.</p>

<p>This is pretty easy to unit test as well, you can simply go <code>viewModel.MyCommand.Execute(null)</code></p>

<p>But this falls down when you start using async, because the lambda will end up being an <strong>async void</strong> method. This means your test can no longer observe what happens in that command. If the implementation throws, your unit test will not know about it and then your test process will crash (if using .net 4.0).</p>

<p>Read <a href="http://blogs.msdn.com/b/lucian/archive/2013/02/18/talk-the-new-async-design-patterns.aspx">Lucians blog post</a> for more information about why async void is bad.</p>

<p>So we introduced a new interface, called <code>IAsyncCommand</code> and it looks like this</p>

<!-- more -->


<pre><code>public interface IAsyncCommand : IAsyncCommand&lt;object&gt;
{
}

public interface IAsyncCommand&lt;in T&gt; : IRaiseCanExecuteChanged
{
    Task ExecuteAsync(T obj);
    bool CanExecute(object obj);
    ICommand Command { get; }
}
</code></pre>

<p>If you were wondering what IRaiseCanExecuteChanged is, it is a really simply interface which means we don&rsquo;t have to cast ICommands. See this <a href="https://gist.github.com/JakeGinnivan/5166866">Gist</a> for the code for that.</p>

<p>You might notice that there is no <code>void Execute(object obj)</code> method on the command, this is to make it impossible to call the async void overload in your unit tests, unless you get the underlying ICommand from the Command property.</p>

<h1>So how does WPF execute the command?</h1>

<p>WPF actually doesnt care about what is exposed via the API, as long as the class implements ICommand, we are good. Introducing AwaitableDelegateCommand:</p>

<pre><code>public class AwaitableDelegateCommand : AwaitableDelegateCommand&lt;object&gt;, IAsyncCommand
{
    public AwaitableDelegateCommand(Func&lt;Task&gt; executeMethod) 
        : base(o=&gt;executeMethod())
    {
    }

    public AwaitableDelegateCommand(Func&lt;Task&gt; executeMethod, Func&lt;bool&gt; canExecuteMethod) 
        : base(o=&gt;executeMethod(), o=&gt;canExecuteMethod())
    {
    }
}

public class AwaitableDelegateCommand&lt;T&gt; : IAsyncCommand&lt;T&gt;, ICommand
{
    private readonly Func&lt;T, Task&gt; _executeMethod;
    private readonly DelegateCommand&lt;T&gt; _underlyingCommand;
    private bool _isExecuting;

    public AwaitableDelegateCommand(Func&lt;T, Task&gt; executeMethod)
        : this(executeMethod, _ =&gt; true)
    {
    }

    public AwaitableDelegateCommand(Func&lt;T, Task&gt; executeMethod, Func&lt;T, bool&gt; canExecuteMethod)
    {
        _executeMethod = executeMethod;
        _underlyingCommand = new DelegateCommand&lt;T&gt;(x =&gt; { }, canExecuteMethod);
    }

    public async Task ExecuteAsync(T obj)
    {
        try
        {
            _isExecuting = true;
            RaiseCanExecuteChanged();
            await _executeMethod(obj);
        }
        finally
        {
            _isExecuting = false;
            RaiseCanExecuteChanged();
        }
    }

    public ICommand Command { get { return this; } }

    public bool CanExecute(object parameter)
    {
        return !_isExecuting &amp;&amp; _underlyingCommand.CanExecute((T)parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { _underlyingCommand.CanExecuteChanged += value; }
        remove { _underlyingCommand.CanExecuteChanged -= value; }
    }

    public async void Execute(object parameter)
    {
        await ExecuteAsync((T)parameter);
    }

    public void RaiseCanExecuteChanged()
    {
        _underlyingCommand.RaiseCanExecuteChanged();
    }
}
</code></pre>

<p>Notice that the AwaitableDelegateCommand implements ICommand, which makes WPF happy, but our viewmodels expose IAsyncCommand, which makes our tests happy. All in all, it works pretty well for me!</p>

<p>If you need a <code>DelegateCommand</code> implementation, check out <a href="https://gist.github.com/JakeGinnivan/5166898">this gist</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Async warning with nSubstitute]]></title>
    <link href="http://jake.ginnivan.net/async-warning-with-nsubstitute/"/>
    <updated>2012-10-16T00:00:00+08:00</updated>
    <id>http://jake.ginnivan.net/async-warning-with-nsubstitute</id>
    <content type="html"><![CDATA[<p>I got sick of a heap of warnings in VS which look like this:</p>

<pre><code>Warning 1   Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.
</code></pre>

<p>The code which was causing this error was a received call: <code>_service.Received().CancelAsync()</code></p>

<p>My solution to the problem is creating a simple extension</p>

<pre><code>public static class NSubstituteHelper
{
    public static void IgnoreAwaitForNSubstituteAssertion(this Task task)
    {

    }
}
</code></pre>

<p>Then my code turns into <code>_service.Received().CancelAsync().IgnoreAwaitForNSubstituteAssertion()</code> and my issue goes away</p>
]]></content>
  </entry>
  
</feed>
