<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: github | Jake Ginnivan's blog]]></title>
  <link href="http://jake.ginnivan.net/blog/categories/github/atom.xml" rel="self"/>
  <link href="http://jake.ginnivan.net/"/>
  <updated>2015-06-08T23:23:43+01:00</updated>
  <id>http://jake.ginnivan.net/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GitReleaseNotes Initial Release!]]></title>
    <link href="http://jake.ginnivan.net/gitreleasenotes/"/>
    <updated>2013-12-17T00:00:00+00:00</updated>
    <id>http://jake.ginnivan.net/gitreleasenotes</id>
    <content type="html"><![CDATA[<p>I have just used GitReleaseNotes to publish a release of GitReleaseNotes on GitHub <a href="https://github.com/JakeGinnivan/GitReleaseNotes/releases/tag/0.2.0">https://github.com/JakeGinnivan/GitReleaseNotes/releases/tag/0.2.0</a>!</p>

<p>I am excited about this project because it will save me a heap of time and effort with managing the open source projects I do releases for.</p>

<p>GitReleaseNotes was another project I kicked off about the same time that <a href="https://github.com/simoncropp">Simon Cropp</a> and <a href="https://github.com/andreasohlund">Andreas Öhlund</a> were kicking off similar projects, see <a href="https://github.com/Particular/ReleaseNotesCompiler">https://github.com/Particular/ReleaseNotesCompiler</a>. We decided to start the projects off down different roads to start with, then maybe merge later once we both could experiment with ideas.</p>

<!-- more -->


<h2>What does it do</h2>

<p>The concept is quite simple, you can optionally specify a Git tag (it will select the newest tag if you do not specify one). It will then scan all newer commits for references to issues.</p>

<p>Once it has all the referenced commits, it will connect the issue tracker you specify, currently GitHub or Jira (and soon YouTrack, TFS and BitBucket) and fetch all the closed issues which have been referenced.
It will then output your release notes in <a href="http://www.semanticreleasenotes.org/">Semantic Release Notes</a> format (which is also markdown) to a file you specify.</p>

<p>It can also publish a release on GitHub, including the generated release notes.</p>

<p>Here are some examples of the types of release notes it can generate:</p>

<p><a href="https://github.com/JakeGinnivan/GitReleaseNotes/blob/master/src/GitReleaseNotes.Tests/ReleaseNotesGeneratorTests.ApproveSimpleTests.approved.txt">Simple single issue release</a><br/>
<a href="https://github.com/JakeGinnivan/GitReleaseNotes/blob/master/src/GitReleaseNotes.Tests/ReleaseNotesGeneratorTests.MultipleReleases.approved.txt">Multiple releases</a></p>

<h2>How to use it</h2>

<p>GitReleaseNotes is a .NET exe, but can be used on ALL project types (JavaScript, Ruby, Java, whatever) because it simply works with Git and whatever issue tracker you use.</p>

<pre><code>GitReleaseNotes.exe /IssueTracker Github /Repo JakeGinnivan/GitReleaseNotes /Token ######################### /OutputFile ReleaseNotes.md
</code></pre>

<p>To Publish, just add the <code>/Publish</code> switch and specify the version you want to publish with the <code>/Version</code> switch. Like so</p>

<pre><code>GitReleaseNotes.exe /IssueTracker Github /Repo JakeGinnivan/GitReleaseNotes /Token ######################### /Publish /Version 0.2.0
</code></pre>

<h2>How to setup on TeamCity</h2>

<p>TeamCity is not required, but I like being able to press a button and my latest CI build gets published.</p>

<p>Well, I am using <a href="https://github.com/JakeGinnivan/GitHubFlowVersion">GitHubFlowVersion</a> which helps me do Semantic Versioning with ease, but if you have another versioning strategy most of the instructions are the same.</p>

<p>Assuming you have a CI build which creates the artifacts, or you have an existing build you will be adding to.</p>

<ol>
<li>Head to <a href="https://github.com/settings/applications">https://github.com/settings/applications</a> and create an access token</li>
<li>Create a new configuration parameter in teamcity called <code>GitHubToken</code>, set the value to the access token you have just created and edit the spec field and paste in <code>password display='hidden'</code>, which will mean your GitHub access token will not be published into any build logs and will just be ####ed out.</li>
<li>Your VCS root must be set to checkout <code>Automatically on Agent</code>, otherwise GitReleaseNotes will not run</li>
<li>Make sure you check GitReleaseNotes.exe into source control so you can access it</li>
<li>Create a new build step which is running a command line application, and make it look something like this<br/>
 <code>GitReleaseNotes\GitReleaseNotes.exe /IssueTracker GitHub /Publish /Token %GitHubToken% /Repo JakeGinnivan/GitReleaseNotes /Version %dep.OpenSourceProjects_GitReleaseNotes_CI.system.GitHubFlowVersion.SemVer%</code></li>
</ol>


<p>My version number is the SemVer of my CI build, if you are using GitHubFlowVersion you will have to create a dummy system.GitHubFlowVersion.SemVer variable, otherwise you cannot reference it across builds (doesn&rsquo;t exist at configure time, it is created when you run GitHubFlowVersion).</p>

<p>And thats it, you can have a build publishing your release notes to GitHub and this will also tag master with the version you have just published.</p>

<p>There are still plenty of issues with this project and heaps of work to do, but I like the way it is shaping up. Feedback/contributions are welcome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git Flow Versioning]]></title>
    <link href="http://jake.ginnivan.net/git-flow-versioning/"/>
    <updated>2013-10-02T00:00:00+01:00</updated>
    <id>http://jake.ginnivan.net/git-flow-versioning</id>
    <content type="html"><![CDATA[<p>As a follow up to my last post <a href="http://jake.ginnivan.net/release-nuget-semver-packages-from-teamcity">http://jake.ginnivan.net/release-nuget-semver-packages-from-teamcity</a> I have been investigating more into different ways to achieve semantic versioning and being able to release in an easy way.</p>

<p>Next stop on my trip was looking into Git-Flow and how it manages releases, initially it seemed very waterfally and too heavy to use on an open source project, but I thought it may fit at different clients. I was instantly drawn to the fact that releases have an explicit step to version at the start of the release process, this is great, I can manage my project, merge pull requests, add features then when I am ready, I can decide to release, put together release notes and figure out if this is a major, minor or patch release.</p>

<p>Much to my surpise, it is actually very light-weight and you can drop much of it if your process is simpler (say for open source).</p>

<p><a href="https://github.com/TestStack/ConventionTests">https://github.com/TestStack/ConventionTests</a> is my guinea pig!</p>

<p>To get started, I decided to try and implement git-flow manually to really understand what is going on. There are plenty of explainations out there, so I will just be running through what I did, and how it works from my point of view. I always have two remotes setup for my projects, &lsquo;upstream&rsquo; is the main repository, &lsquo;origin&rsquo; is my fork.</p>

<!-- more -->


<h2>1. Convert the repo over to git-flow</h2>

<p>From your git command line</p>

<pre><code>git checkout master
git fetch upstream
git merge upstream/master
git checkout develop
git push upstream develop
</code></pre>

<p>This pushes the <code>develop</code> branch into your repo, then head to the project settings in github and change the default branch to <code>develop</code>.</p>

<h2>2. Install GitFlowVersion</h2>

<p>I am a big fan on Simon Cropp&rsquo;s (<a href="https://twitter.com/SimonCropp">https://twitter.com/SimonCropp</a>) work. He has been working on <a href="https://github.com/Particular/GitFlowVersion">https://github.com/Particular/GitFlowVersion</a> with Andreas Öhlund.</p>

<p>Basically GitFlowVersion uses the conventions in place in git-flow to make it really easy to version your software.</p>

<p>Once up and running, tags off <code>master</code> get a normal version, say <code>v2.1.0</code> (assume this is the LAST tagged release), develop CI builds get the version <code>v2.2.0-unstable20</code> where the minor is LASTMINOR + 1 and there has been 20 commits since the last tag on master. Or <code>v&lt;major&gt;.&lt;minor+1&gt;.0-unstable&lt;#commitssincelastrelease&gt;</code>
Release branches have a version of <code>v2.2.0-beta</code> where 2.2.0 is the version you have put in the release branch name (in this case <code>release-2.2.0</code>)
You can also tag a release branch as <code>rc1</code> or <code>rc2</code> and the version will become <code>v2.2.0-&lt;tag&gt;</code>.</p>

<p>If this sounds confusing, its not, and it is all pretty automatic, read on to see what it actually means for you maintaining a project.</p>

<h2>3. Contributing/Pull Requests</h2>

<p>I always use feature branches, but not for an entire feature. I use very short lived branches, which I put up as a pull request as soon as I am done. I am known to submit 3+ pull requests all within the space of an hour when I work on a project because I just fix a bunch of small things.</p>

<p>Nothing much changes here, except you take you branch from <code>develop</code>. So</p>

<pre><code>git checkout develop
git fetch upstream
git merge upstream/develop
git checkout -b FixingSomething
</code></pre>

<p>Pull requests now target <code>develop</code>, so I do my commits, push to origin like normal and submit my pull request targeting <code>develop</code></p>

<p>Your CI build (assuming you are building pull requests) will trigger with build number <code>v2.2.0-PullRequest50</code>, where the version is the last release, with the minor bumped, just like develop version numbers, except the semver tag is PullRequest&lt;PR#>.
I think that is pretty neat.</p>

<h2>4. Releasing a new version</h2>

<p>When you decide you want to release, or start preparing a release you can either take a release branch, or merge develop straight into master and tag master with the release (afaik this doesn&rsquo;t cause any issues :P)</p>

<p>In my mind there are two styles to run a project,</p>

<ol>
<li>every checkin builds, then if tests pass autodeploys. These projects cannot adhere to semantic versioning, but the changes are often so tiny that upgrades pose little risk.</li>
<li>At some point in time, the decision to release is made, this could be as soon as a pull request is merged, or after a particular milestone is reached. All the projects I am currently contributing to work in this way.</li>
</ol>


<h3>4.1 Using a release branch</h3>

<p>Using a release branch allows you to make the decision I am going to release, there may be a few things I know I have to do before releasing (DbUp is a great example of this). But I don&rsquo;t want to stop being able to merge pull requests. To release using a branch (assume develop is up to date), and I am only fixing a bug in the current v2.1.0 release</p>

<pre><code>git checkout -b release-2.1.1
</code></pre>

<p>or</p>

<pre><code>git flow release start 2.1.1
</code></pre>

<p>I can now leave this branch open for a bit, do the work I need to do to release 2.1.1 or send it to someone else on the team to OK. I could even release the 2.1.1 build as a pre-release package on NuGet. It would have version 2.1.1-beta1 remember.</p>

<p>Once I am happy, either the pre-release package has got the feedback I wanted, or I have made the additional changes I need I simply merge the branch to master (with the &ndash;no-ff option), tag, then delete the remote branchs. Remember this is if you are doing it manually, you can also just go <code>git flow release finish</code> if you have the git-flow extensions installed, or use source tree and click a button :P The first two commands are not needed if you haven&rsquo;t committed anything to the release branch</p>

<pre><code>git checkout develop
git merge release-2.1.1 --no-ff
git checkout master
git merge release-2.1.1 --no-ff
git tag 2.1.1
</code></pre>

<p>or</p>

<pre><code>git flow release finish 2.1.1
</code></pre>

<p>Then publish</p>

<pre><code>git push upstream master
git push --tags
git branch -d release-2.1.1
git push upstream :release-2.1.1
</code></pre>

<p>or</p>

<pre><code>git flow release publish 2.1.1
</code></pre>

<h3>4.2 Skip release branch</h3>

<p>If you don&rsquo;t want to bother with the release branch, you could also just go</p>

<pre><code>git checkout master
git merge develop --no-ff
git tag 2.1.1
git push upstream master
git push --tags
</code></pre>

<h2>5. Publish the build</h2>

<p>Now you have the release build from your CI you can progress through your build pipeline and release to NuGet or publish to a test environment or whatever the first step is in your Continuous Delivery pipeline.</p>

<h2>That&rsquo;s it</h2>

<p>I think Git-Flow is actually not too bad for releasing projects using semantic versioning, most of the time in this is writing the release notes, seeing what has changed since the last release (which is really easy due to the conventions in place!) and checking to see if you have any breaking changes which would mean a major version bump.</p>

<p>As a summary. Here is me fixing and releasing a feature as a pre-release package. The current version on NuGet is currently v2.2.0</p>

<pre><code>git fetch upstream
git checkout develop
git merge upstream/develop
git checkout -b SomeFeature

# Work..
git commit -am "Some experimental feature"
git push origin SomeFeature

# Submit pull request, so NOTHING has changed yet, this PR is merged
git fetch upstream
git checkout develop
git merge upstream/develop # to get my changes into my local develop branch

# So now I am starting the release, nothing before here is new if you are using GitHub flow
git checkout -b release-2.3.0
git push upstream release-2.3.0
</code></pre>

<p>Now my CI builds, and I click the button to promote the last CI build as a pre-release NuGet package. Once I am happy, I have got my feedback</p>

<pre><code>git checkout master
git merge release-2.3.0 --no-ff
git tag 2.3.0
git push upstream master
git push upstream --tags
</code></pre>

<p>My CI will build, and I can click the publish button on teamcity to release to NuGet.</p>

<p>Thoughts? Do you know of an easier way. I am REALLY open to suggestions and willing to try stuff out at the moment :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release NuGet SemVer packages from Teamcity]]></title>
    <link href="http://jake.ginnivan.net/release-nuget-semver-packages-from-teamcity/"/>
    <updated>2013-09-28T00:00:00+01:00</updated>
    <id>http://jake.ginnivan.net/release-nuget-semver-packages-from-teamcity</id>
    <content type="html"><![CDATA[<p>I have a number of open source projects and I do not really have a <strong>good</strong> release process. So I spend the arvo trying to figure out a good way to do it.</p>

<p>My goals were</p>

<ul>
<li>Use GitHubs releases feature - <a href="https://github.com/blog/1547-release-your-software">https://github.com/blog/1547-release-your-software</a></li>
<li>I want to release from NuGet</li>
<li>Preferably write release notes before I click the button in TeamCity, this way i can add them on github to build up a release</li>
<li>Support SemVer, including pre-release packages</li>
<li>Assembly versions should be stamped with informational version as well as a version</li>
<li>Be able to link to the project GitHub releases from the NuSpec</li>
</ul>


<!-- more -->


<h1>My Solution</h1>

<h2>1. Setup the VCS Root to be authenticated</h2>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/ReleaseNuGetSemVerpackagesfromTeamcity.png" alt="ReleaseNuGetSemVerpackagesfromTeamcity" /></p>

<p>Then tell TeamCity to Label Successful builds
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity11_635160285120295000.png" alt="Release-NuGet-SemVer-packages-from-Teamcity11" /></p>

<h2>2. Setup some additional build parameters</h2>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity_635160285057326250.png" alt="Release-NuGet-SemVer-packages-from-Teamcity" /></p>

<h3>2.1. AssemblyVersion</h3>

<p>This is the assembly version, only change this for major releases, this will save people adding binding redirects when different projects rely on different versions
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity1_635160285061232500.png" alt="Release-NuGet-SemVer-packages-from-Teamcity1" /><br/>
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity2_635160285065138750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity2" /></p>

<p>If you want the text version of the spec, it is</p>

<pre><code>text description='The assembly version which will be stamped (assembly info version/nuget version will be the build number)' display='prompt' label='AssemblyVersion' validationMode='not_empty'
</code></pre>

<h3>2.2. Prerelease</h3>

<p>This is a checkbox, when ticked it&rsquo;s value is <code>-pre</code> so we can just use it in the version
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity3_635160285069201250.png" alt="Release-NuGet-SemVer-packages-from-Teamcity3" /><br/>
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity4_635160285073263750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity4" /></p>

<p>Once again the text version of the spec is</p>

<pre><code>checkbox checkedValue='-pre' description='Check this box if you want a pre-release' display='prompt' label='PreRelease?'
</code></pre>

<h3>2.3. Version</h3>

<p>This is the version which you will pass to NuGet when you are creating your package
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity5_635160285077170000.png" alt="Release-NuGet-SemVer-packages-from-Teamcity5" /><br/>
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity6_635160285081076250.png" alt="Release-NuGet-SemVer-packages-from-Teamcity6" /></p>

<pre><code>text description='This is the version number, adjust the major/minor as needed to conform to semver' display='prompt' label='VersionNumber' validationMode='not_empty'
</code></pre>

<h3>2.4. env.Version</h3>

<p>This is just so the version gets set as an environmental variable so my build scripts can pick it up</p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity7_635160285084513750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity7" /></p>

<p>I am not sure if this is actually needed.</p>

<h2>3. Build Steps</h2>

<p>I always have a <code>.proj</code> file checked in for all of my projects which contain all logic to build the solution, I just have to tell teamcity what targets to invoke. If you want to view my build script, check out <a href="https://github.com/TestStack/ConventionTests/blob/master/ConventionTests.proj">https://github.com/TestStack/ConventionTests/blob/master/ConventionTests.proj</a></p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity8_635160285101388750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity8" /></p>

<p>The Test target builds and runs my unit tests, then the Publish Target builds the NuGet packages, step 2 of my TeamCity build is Publish to NuGet</p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity9_635160285112638750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity9" /></p>

<p>Finally, the assembly info stamping build feature. Click <strong>Add build feature</strong></p>

<p>We want to use two different versions from our config, remember from above we have</p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity10_635160285116545000.png" alt="Release-NuGet-SemVer-packages-from-Teamcity10" /></p>

<h2>4. Update the build version</h2>

<p>Finally go to the General Settings of your build, and update the build number format to be: <code>%Version%</code> and we set the build counter to 0</p>

<h1>Releasing a new version</h1>

<p>So now, we have to stick to SemVer, let us run through a scenario of releasing a minor release (new non-breaking feature) of TestStack.ConventionTests. The current release is v2.0.0. I first need to reset the build counter back to 0, if you don&rsquo;t want to mess with the build counter, just change the VersionNumber variable to have a manually updated patch version. This actually is probably better because then the version numbers are more predictable.</p>

<h2>Create release definition in GitHub</h2>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity16_635160285172951250.png" alt="Release-NuGet-SemVer-packages-from-Teamcity16" />
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity17_635160285176857500.png" alt="Release-NuGet-SemVer-packages-from-Teamcity17" /></p>

<p>Specify the release notes for this release
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity18_635160285180763750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity18" /></p>

<p>Do not have the Publish Release box ticked, otherwise GitHub will create the tag for you.</p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity19_635160285184670000.png" alt="Release-NuGet-SemVer-packages-from-Teamcity19" /></p>

<h2>Release from TeamCity</h2>

<p>I click <em>Run</em> in TeamCity, and I will be prompted to confirm everything</p>

<p><img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity14_635160285165138750.png" alt="Release-NuGet-SemVer-packages-from-Teamcity14" /></p>

<p>Because this is a minor release, I increment the minor version number
<img src="/assets/posts/2013-09-28-release-nuget-semver-packages-from-teamcity/Release-NuGet-SemVer-packages-from-Teamcity15_635160285169045000.png" alt="Release-NuGet-SemVer-packages-from-Teamcity15" /></p>

<p>Now hit run, this will publish to NuGet and create the tag in Git. The final step is to go back to GitHub and publish the release (this is not done automatically, and I&rsquo;m sure it could be automated through the GitHub API).</p>

<p>This is my first attempt at making it easy for me to release my open source projects with SemVer and GitHub Releases</p>
]]></content>
  </entry>
  
</feed>
