<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Patternsandpractices | Jake Ginnivan's blog]]></title>
  <link href="http://JakeGinnivan.github.io/blog/categories/patternsandpractices/atom.xml" rel="self"/>
  <link href="http://JakeGinnivan.github.io/"/>
  <updated>2014-01-05T16:26:22+00:00</updated>
  <id>http://JakeGinnivan.github.io/</id>
  <author>
    <name><![CDATA[Jake Ginnivan]]></name>
    <email><![CDATA[jake@ginnivan.net]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[VSTO and COM Interop]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-com-interop/"/>
    <updated>2010-05-14T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-com-interop</id>
    <content type="html"><![CDATA[<p>In this post I will give an introduction to COM Interop and covering some of the basic concepts you need to understand when dealing with VSTO and the Office Object Model. By understanding the way COM interop works and the potential impact of not deterministically cleaning up your references you will build much more reliable VSTO add-ins.</p>

<p>After covering the basics of COM Interop I will write about a helper library I have written and have code examples of how it can make your life much easier.</p>

<!-- more -->


<h1>COM Interop Overview</h1>

<p>Hopefully you have a bit of a understanding about how it works, but I really want to explain my experiences and pull some of the high level concepts that will help you develop against the Office Object Model..</p>

<p>For any .NET application to talk to unmanaged code we need a .NET Interop Assembly which contains meta data about the types exposed in the COM component. When you add a reference to a COM component through the Add References dialog, visual studio will call the command line tool Tlbimp.exe and generate us a type library for that COM component, then the reference will be added to that Interop Assembly that we have generated. Publishers will often provide Primary Inerop Assemblies (PIA’s) which are signed Interop Assemblies by the publisher which prevent conflicts between different applications having their own generated Interop assemblies. I will refer to both as PIA’s from now on.</p>

<p>Once we have our PIA’s .NET makes it very easy for us to interact with the COM types. Whenever a COM object crosses into our .NET application the CLR creates a runtime callable wrapper (RCW) which consumes the IUnknown (which provides object identity, type coercion and lifetime management) and IDispatch (used for late binding through reflection) and gives us an instance of the RCW which implements the interface of the type we requested. See below where the .NET client is given a RCW implementing the INew interface.
<img src="/get/screenshots/rcw.png" alt="RCW" /></p>

<p>There is a RCW created for every instance of a particular COM object. This means we can have references to a single RCW in multiple area’s of our application.</p>

<h2>Memory Models</h2>

<p>So all sounds really easy for the moment, we add a reference to our PIA’s, then .NET will do its best to make it seem like we are talking to a managed library and try to take care of all the memory management itself, after all that is what we are used to as .NET developers.</p>

<p>The problem is .NET memory management is non-deterministic, meaning we do not know when our memory will be cleaned up by the garbage collector. COM on the other hand is unmanaged and follows a deterministic memory cleanup model. These models do not work well together.
<img src="/get/screenshots/memorymodels.png" alt="Memory Models" /></p>

<p>What is actually happening in the above diagram is when the garbage collector runs, it finds a RCW that has no references inside the managed process the garbage collector proceeds to clean up the RCW. The RCW actually implements a finaliser which releases all the associated COM references.</p>

<p>By relying on the finaliser of the RCW it means that it requires at least two garbage collections to clean up our COM references. If you want to read about this in more detail check out <a href="http://msdn.microsoft.com/en-us/magazine/bb985010.aspx">http://msdn.microsoft.com/en-us/magazine/bb985010.aspx</a>.</p>

<p>Microsoft have provided us with a method to clean up our COM references in a deterministic way. When you call Marshal.ReleaseComObject on a COM object it decrements the RCW’s reference counter, when this counter reaches 0 the underlying COM references are released. By calling ReleaseComObject on every COM object we request when we are finished with it we bring the two memory models closer together and can avoid hard to diagnose ‘ghost’ inspectors in Outlook (will explain later in the post).</p>

<h2>How to achieve deterministic cleanup in .NET</h2>

<p>Now that I have covered the basics of COM interop, we can look at ways to code in a deterministic manner.</p>

<h3>Only ever use a single . (period) in lines of code</h3>

<p><strong>Example:</strong> xlApp.Workbooks.Add()</p>

<p>What is happening behind the scenes is we have a RCW for the <em>ExcelApplication interface, .Workbooks gives us a RCW implementing </em>WorkBooks interface, then we call the Add method which returns a _Workbook RCW.</p>

<p>We have just lost the reference to a WorkBooks COM object. You can never force the release of those resources now, and Excel 2003 will not exit without killing the process (2007 has code that detects leaked objects and will clean up after you on exit).</p>

<h3>Do not call Marshal.ReleaseComObject on an object that has left the current scope</h3>


<p>f you let a COM object leave the scope it was instantiated in you probably can no longer guarantee that you have the only reference in your application. If you call Marshal.ReleaseComObject, the next time another area of your app makes a call to that COM object you will get a InvalidComObjectException thrown.
<img src="/get/screenshots/invalidcomobjectException.png" alt="InvalidComObjectException" /></p>

<p>The Visual Studio team posted on their blog a really interesting post titled “Marshal.ReleaseComObject Considered Dangerous“. Have a read at <a href="http://blogs.msdn.com/visualstudio/archive/2010/03/01/marshal-releasecomobject-considered-dangerous.aspx">http://blogs.msdn.com/visualstudio/archive/2010/03/01/marshal-releasecomobject-considered-dangerous.aspx</a></p>

<h3>Call Marshal.ReleaseComObject on every COM object you bring into the managed process. (That does not leave that method scope)</h3>

<p>Every COM object you get by accessing a property or calling a method you should release. For techniques on how to not let the COM object leave the current method scope check out my last blog post covering <a href="/vsto-data-access-repositories">Outlook data repositories</a>. Your goal should be to not let those COM objects leave the current scope, because once they do you shouldn’t release them explicitly anymore.</p>

<h3>Release each item that is enumerated in a foreach loop</h3>

<p>Foreach loops are a very big trap. Take:
foreach (var item in folder.Items) { }</p>

<p>That simple line of code leaks an Items collection, and every item that is enumerated is also leaked. I have a helper extension that makes it much easier. I will cover it closer to the end of the post.</p>

<h2>Issues with not releasing</h2>

<p>It is not just memory or ‘best practise’ that has made me look into this so much, there are many REAL problems that can be caused if you do not release your COM resources.</p>

<h3>Application doesn’t exit</h3>

<p>If you have ever done excel automation and used COM interop to generate excel documents on a server (I don’t recommend this by the way  ) then you probably have found that even though you call .Exit() on the excel API the process still hangs around. This is because you have missed releasing a resource, or released them in the wrong order.</p>

<h3>Ghost Inspectors</h3>

<p>If you have used Outlook a lot, you probably would have experienced this and just put it down to something strange happened. Here is what happens, I open a contact.</p>

<p>Then I press Save &amp; Close and am left with</p>

<p><img src="/get/screenshots/ghostinspector.png" alt="Ghost Inspector" /></p>

<p>The ribbon gets greyed out. What has happened is the Inspector (the window) is no longer associated to the item it was displaying, but because of a leaked reference the Inspector did not close correctly. You CANNOT close this window through code (unless you find the window and close it through WIN32). I will cover this in more detail in another post, I still have not figured out how to not cause ghost inspectors sometimes when the inspector is opened modally.</p>

<h3>Unable to resize appointments in calendar</h3>

<p>One add-in I wrote synchronised calendar items. After a synchronisation you could no longer resize items in your calendar. This was due to not releasing each Appointment and all the child properties I accessed (user properties).</p>

<p>As you can see, by not releasing the resources you access you can hit very hard to diagnose issues. You are much better off enforcing the I must release everything I access. (It is also a good idea to check Marshal.IsComObject() before you call release. Maybe put it in an extension method or a static helper method. Check out how I have done it in Outlook.Utility.</p>

<h2>How to make this easier</h2>

<p>I have spent some time creating some extension methods which makes dealing with COM objects much cleaner, and safer.</p>

<p>The first problem I wanted to reduce the amount of boiler plate code to make sure you deterministically clean up your COM references.</p>

<p>Enter the WithComCleanup extension method. Take this code:</p>

<pre><code>void Main()
{
    _Application app;
    _NameSpace session;
    _MAPIFolder folder;
    Items contactItems;
    try
    {
        app = new Application();
        session = app.Session;
        folder = session.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
        contactItems = folder.Items;
        foreach (_ContactItem contactItem in folder.Items)
        {
            try
            {
                if (!string.IsNullOrEmpty(contactItem.FullName))
                {
                    contactItem.FileAs = contactItem.FullName;
                    contactItem.Save();
                }
            }
            finally
            {
                if (Marshal.IsComObject(contactItem))
                    Marshal.ReleaseComObject(contactItem);
            }
        }
    }
    finally
    {
        if (contactItems != null &amp;&amp; Marshal.IsComObject(contactItems))
            Marshal.ReleaseComObject(contactItems);
        if (folder != null &amp;&amp; Marshal.IsComObject(folder))
            Marshal.ReleaseComObject(folder);
        if (session != null &amp;&amp; Marshal.IsComObject(session))
            Marshal.ReleaseComObject(session);

        if (app != null)
        {
            app.Quit();
            if (Marshal.IsComObject(app))
                Marshal.ReleaseComObject(app);
        }
    }
}
</code></pre>

<p>Each COM variable must be declared out of the try/finally scope, and for each COM object we have to check if its null, and that it is a COM object (not only can you use COM objects in .NET, you can also implement a COM interface in .NET and pass it into the unmanaged application, you can read about COM Callable Wrappers at <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(VS.71).aspx">http://msdn.microsoft.com/en-us/library/f07c8z1c(VS.71).aspx</a>), but this means you can get a .NET object when you are expecting a COM object, as more parts of Office become managed this will mean you code will not break.</p>

<p>Now lets use the WithComCleanup extension method:</p>

<pre><code>void Main()
{
    using (var app = new Application().WithComCleanup())
    {
        using (var session = app.Resource.Session.WithComCleanup())
        {
            var folder = session.Resource.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
            using (var contactsFold = folder.WithComCleanup())
            {
                foreach (var contactItem in contactsFold.Resource.Items.ComLinq&lt;_ContactItem&gt;())
                {
                    if (!string.IsNullOrEmpty(contactItem.FullName))
                    {
                        contactItem.FileAs = contactItem.FullName;
                        contactItem.Save();
                    }
                }
            }
        }
        app.Resource.Quit();
    }
}
</code></pre>

<p>This code is functionally identical to the last snippet. What is happening is our COM resource is being wrapped in a AutoCleanup<T> object which implements IDisposable, which allows you to use a using statement to wrap each com object. It means more indentation, but I think it results in much cleaner code.</p>

<p>Another thing you may notice is you now must access your COM object through the .Resource property. Lets have a look at another example. In this example I simply want to access a custom property on each Contact in Outlook.</p>

<pre><code>void Main()
{
    _Application app;
    _NameSpace session;
    _MAPIFolder folder;
    Items contactItems;
    try
    {
        app = new Application();
        session = app.Session;
        folder = session.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
        contactItems = folder.Items;
        foreach (_ContactItem contactItem in folder.Items)
        {
            UserProperties userProperties;
            UserProperty property;
            try
            {
                //Create a user property on every contact
                userProperties = contactItem.UserProperties;
                property = userProperties.Find("CustomProperty", true);
                if (property == null)
                    property = userProperties.Add(name, OlUserPropertyType.olText, false, Type.Missing);

                property.Value = "Value";
                //Dont save, just a demo
            }
            finally
            {
                if (Marshal.IsComObject(property))
                    Marshal.ReleaseComObject(property);
                if (Marshal.IsComObject(userProperties))
                    Marshal.ReleaseComObject(userProperties);
                if (Marshal.IsComObject(contactItem))
                    Marshal.ReleaseComObject(contactItem);
            }
        }
    }
    finally
    {
        if (contactItems != null &amp;&amp; Marshal.IsComObject(contactItems))
            Marshal.ReleaseComObject(contactItems);
        if (folder != null &amp;&amp; Marshal.IsComObject(folder))
            Marshal.ReleaseComObject(folder);
        if (session != null &amp;&amp; Marshal.IsComObject(session))
            Marshal.ReleaseComObject(session);

        if (app != null)
        {
            app.Quit();
            if (Marshal.IsComObject(app))
                Marshal.ReleaseComObject(app);
        }
    }
}
</code></pre>

<p>This is still a REALLY simple app, I think there is probably 80% boiler plate code to ensure all our COM references are cleaned up and Outlook shuts down gracefully.</p>

<p>Enter the ComLinq and the Get/SetUserProperty extension methods.</p>

<pre><code>void Main()
{
    using (var app = new Application().WithComCleanup())
    {
        using (var session = app.Resource.Session.WithComCleanup())
        {
            var folder = session.Resource.GetDefaultFolder(OlDefaultFolders.olFolderContacts);
            using (var contactsFolder = folder.WithComCleanup())
            using (var contactItems = contactsFolder.Resource.Items.WithComCleanup())
            {
                foreach (var contactItem in contactItems.ComLinq&lt;_ContactItem&gt;())
                {
                    contactItem.SetPropertyValue("CustomProperty", OlUserPropertyType.olText, "Value", addToFolder: false);
                }
            }
        }
        app.Resource.Quit();
    }
}
</code></pre>

<p>That is a massive reduction in code, lets look at what is actually happening here.</p>

<p>First lets look at our loop:</p>

<pre><code>foreach (var contactItem in contactItems.ComLinq&lt;_ContactItem&gt;())
</code></pre>

<p>Under the covers the ComLinq extension will wrap any IEnumerable (not the generic version) in custom generic IEnumerable, which has a IEnumerator that disposes the COM objects it enumerates as it enumerates the collection.</p>

<p>The key thing to remember is that the items MUST NOT leave the scope of the foreach loop because the RCW’s will be poisoned as soon as the enumerator moves to the next item.</p>

<pre><code>contactItem.SetPropertyValue("CustomProperty", OlUserPropertyType.olText, "Value", addToFolder: false);
</code></pre>

<p>Now lets have a look at the SetPropertyValue extension method (there is also a GetPropertyValue extension method as well).</p>

<p>It takes 4 arguments, first is the name of the Property, second is the type, third is the value we want to set, then 4th is a flag to add the UserProperty to the parent folder, this allows you to search your custom property through the Outlook UI. For example in my FacebookToOutlook demo application I use it to filter appointments to facebook events.
<img src="/get/screenshots/outlookCustomerFolderProperty.png" alt="Custom Folder Property" /></p>

<p>The signature of the GetUserProperty extension method looks like this:</p>

<pre><code>T GetPropertyValue&lt;T&gt;(UserProperties userProperties, string name, OlUserPropertyType type, bool create, Func&lt;object, T&gt; converter, T defaultValue)
</code></pre>

<p>And you can call it like this:</p>

<pre><code>_appointmentItem.GetPropertyValue(FacebookeventidProperty, OlUserPropertyType.olText, false, Convert.ToInt64, -1)
</code></pre>

<p>As you can see it simplifies the syntax greatly, by using type intference with the converter and the default value we get a strongly typed way to get custom properties that cleans up all the COM resources it accesses deterministically.</p>

<p>Check out these extensions plus other helpers in my Outlook.Utility project at <a href="http://vstocontrib.codeplex.com/">http://vstocontrib.codeplex.com/</a> to get the source code and see what other useful helpers are in that library.</p>

<h1>Wrap up</h1>

<p>This has been a pretty big post, which I hope is useful to people. I have not covered events and quite a lot of other things, but starting with knowing how COM interop basically works and deterministically cleaning up as many COM resources are you can make your life much easier.</p>

<p>If you have feedback, please contact me.</p>

<h2>Resources</h2>

<p>If you would like to read more about this check out these links:</p>

<p><a href="http://www.guidanceshare.com/wiki/Interop_(.NET_1.1)_Performance_Guidelines_-_Marshal.ReleaseComObject">http://www.guidanceshare.com/wiki/Interop<em>(.NET_1.1)</em>Performance_Guidelines<em>&ndash;</em>Marshal.ReleaseComObject</a> – DotNet 1.1, but still good</p>

<p><a href="http://blogs.msdn.com/mbend/archive/2007/04/18/the-mapping-between-interface-pointers-and-runtime-callable-wrappers-rcws.aspx">http://blogs.msdn.com/mbend/archive/2007/04/18/the-mapping-between-interface-pointers-and-runtime-callable-wrappers-rcws.aspx</a></p>

<p><a href="http://www.add-in-express.com/creating-addins-blog/2008/10/30/releasing-office-objects-net/">http://www.add-in-express.com/creating-addins-blog/2008/10/30/releasing-office-objects-net/</a> – I don’t use add-in express. But the content on this page is good.</p>

<p><a href="http://msdn.microsoft.com/en-us/magazine/cc163316.aspx">http://msdn.microsoft.com/en-us/magazine/cc163316.aspx</a> &ndash; Managing Object Lifetime, good stuff, talks about deterministic finalisation in .NET</p>

<p><a href="http://samteknik.blogspot.com/">http://samteknik.blogspot.com/</a> – It looks like Samir only started blogging late last year, but the two posts he has on his blog are a good read.</p>

<p><a href="http://msdn.microsoft.com/en-us/library/8023ct8s(VS.100).aspx">http://msdn.microsoft.com/en-us/library/8023ct8s(VS.100).aspx</a> – COM interfaces explanation</p>

<p><a href="http://msdn.microsoft.com/en-us/library/8bwh56xe(VS.100).aspx">http://msdn.microsoft.com/en-us/library/8bwh56xe(VS.100).aspx</a> – RCW description</p>

<p><a href="http://blogs.msdn.com/vcblog/archive/2006/09/20/762884.aspx">http://blogs.msdn.com/vcblog/archive/2006/09/20/762884.aspx</a> &ndash; Mixing deterministic and non-deterministic cleanup</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Structure a New VSTO Project]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-project-structure/"/>
    <updated>2010-04-23T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-project-structure</id>
    <content type="html"><![CDATA[<p>Without a good project structure you will find you cannot test any of your code and will possibly run into maintainability problems. For my user group talk last month I built a Outlook add-in that synchronises contacts and events from Facebook into outlook. I chose Facebook because it has a easy to access public API and most people are familiar with it. Over the next few weeks I will go through the process of building it, demonstrating many concepts as I go. At the end I will release the completed project.</p>

<!-- more -->


<h1>File &ndash;> New</h1>

<p><img src="/get/screenshots/NewOutlookAddin.png" alt="New Outlook Add-in" /></p>

<p>I am targeting .NET 4.0 (Full, not client profile) and Outlook 2010, but all the concepts can easily be transferred back to 3.5 and Office 2003/2007.</p>

<p><img src="/get/screenshots/EmbedInteropTypes.png" alt="Embed Interop Types" /></p>

<p>.NET 4.0 has a new feature to embed Interop types into the assembly, I disable this because it has caused me issues resolving COM types through my IoC container (not all IoC containers recognise type equivalence yet), and I also expect the user to have the Office PIA’s installed. Read more about the feature here.</p>

<p>Next create a Core library, this project contains all your IoC registration, type mappings (Automapper, use it, I will cover why in another post =D). Then rename Class1.cs to AddinCore.cs, AddinCore.cs will contain all of our bootstrapping code and it keeps ThisAddin.cs very small.</p>

<p>There are two main reasons for keeping ThisAddin.cs small.</p>

<ol>
<li>If we want to target Office 2003/2007 and 2010 and take advantage of the UI on each, we need different add-ins, because all our code is in a library we do not have code duplication.</li>
<li>You cannot add references to VSTO projects, which makes any code within your VSTO project untestable.</li>
</ol>


<p>So now we have:
<img src="/get/screenshots/AddinSolutionExplorer.png" alt="Solution Explorer" /></p>

<p>From here you should add all application specific code into the .Core project, and the only code you should add to the actual add-in itself is UI related items like Ribbons, Custom Task Panes, Toolbars (for Office 2007/2003) and Form regions.</p>

<p>Now just create a test project to test our .Core project and we are off and racing. For my next post I will add IoC support into our application and show you how you can inject dependencies into Ribbons.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Outlook Items, Repositories & Data Access]]></title>
    <link href="http://JakeGinnivan.github.io/vsto-data-access-repositories/"/>
    <updated>2010-04-23T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/vsto-data-access-repositories</id>
    <content type="html"><![CDATA[<p>If we want to do anything interesting with VSTO and Outlook we will have to access data from Outlook. That will normally be Contacts, or Appointments or Emails? When you do this you will probably leak items, then Outlook will stop behaving normally, you can get ghost inspectors (click save &amp; close, and the window stays open, but ribbon is grayed out), or errors when you try to edit a item through the Outlook UI. There can be many side effects, most are not fun to track down the cause.</p>

<!-- more -->


<h1>Repository Pattern</h1>


<p>This seems as good a place as any to cover the repository pattern, it is REALLY important if you want a stable VSTO app. If you are unsure what it is then have a read of <a href="http://martinfowler.com/eaaCatalog/repository.html">http://martinfowler.com/eaaCatalog/repository.html</a>.</p>

<p>Essentially my repository interfaces will expose methods like GetAppointments(), SaveAppointment(), NewAppointment() etc. I will use repositories rather than interacting with the Outlook session directly. This prevents me accidently leaking COM objects.</p>

<p>To achieve a non leaking high performance repository no matter what thread you call from we have to use a few patterns and Automapper to put it all together. Here is a class diagram of the end goal.</p>

<p><img src="/get/screenshots/OutlookEventRepository.png" alt="Outlook Event Repository" /></p>

<p>Notice that my repository returns a basic CLR interface, not appointment items.</p>

<p>FacebookEventAdapter – uses the adapter pattern to adapt the ugly and HUGE <em>AppointmentItem interface to something that is useful to us. It is essentially a wrapper class that adapts the </em>AppointmentItem interface to our own interface.</p>

<p><img src="/get/screenshots/IOutlookFacebookEvent.png" alt="Outlook event interface" /></p>

<p>The next step is we do not want our repository to leak. For the moment trust me that we do not want to leak COM objects. I will cover why it is bad in a later post.</p>

<p>This is the point that AutoMapper is essential:</p>

<pre><code>public IList&lt;IOutlookFacebookEvent&gt; GetEvents()
{
    var events = new List&lt;IOutlookFacebookEvent&gt;();
    using (var calendar = _session.GetDefaultFolder(OlDefaultFolders.olFolderCalendar).WithComCleanup())
    using (var items = calendar.Resource.Items.WithComCleanup())
    {
        events.AddRange(
            items.Resource
                .ComLinq&lt;AppointmentItem&gt;()
                .Select(appointment =&gt; new FacebookEventAdapter(appointment))
                .Select(adapter =&gt; Mapper.Map(adapter, new OutlookFacebookEvent(adapter.RsvpStatus, adapter.EntryId)))
                .Where(e =&gt; e.EventId != -1));
    }

    return events;
}
</code></pre>

<p>Ignore the WithComCleanup and ComLinq extension methods for now, I will cover them in a later post (or check out Outlook.Utility which contains those extensions). They simply make sure that the COM objects are cleanly disposed of and stop COM object leaks.</p>

<p>What is important is that we wrap our appointmentItem in the adapter, then we map the adapter to our CLR implmentation of our interface. And there is only 1 line of code need to make the mapping work:</p>

<pre><code>Mapper.CreateMap&lt;FacebookEventAdapter, OutlookFacebookEvent&gt;();
</code></pre>

<p>Here is a step by step description of what is happening:</p>

<ol>
<li>Get the Calendar folder from Outlook</li>
<li>Get all Items in the collection</li>
<li>ComLinq exposes a custom IEnumerable<T> which returns a custom IEnumerator<T> which releases the COM objects as soon as the enumerator moves onto the next item. And has the added advantage that it gives is Linq to Object support on the COM collection =)</li>
<li>For each _AppointmentItem in the calendar, wrap it in a FacebookEventAdapter</li>
<li>Then Map the adapter to a new CLR implementation of our IOutlookFacebookItem interface.</li>
<li>Filter any items that are not Facebook events.</li>
<li>Add the resulting items to the events list and return it.</li>
</ol>


<p>The end result is that we return clean CLR objects which have no COM references and all the COM objects that were brought into .NET have been released before we return.</p>

<h1>Dispatching Repository</h1>


<p>As I said before Outlook runs in a STA. This means that if we call our repository from a background thread (which you will do if you are doing synchronisation or some other expensive operation) every time we interact with the Outlook Interop API we cause the call to be marshalled across threads.</p>

<p>The solution – a repository <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator</a> which makes any repository calls on the Outlook STA thread, so we have only a single call that has to be marshalled across threads, then all Outlook calls will already be in the STA so no marshalling required.</p>

<p>I setup a small test app to test my theory that I would actually get performance gains by doing this, and I was amazed at the results.</p>

<p><strong>Mapping ~1000 Appointments to CLR objects</strong></p>

<blockquote><p>Background repository mapped in ~10 seconds <br />
Dispatched repository mapped in ~4 seconds</p></blockquote>

<p><strong>Mapping 16 Appointments to CLR objects</strong></p>

<blockquote><p>Background repository mapped in ~1.6 seconds <br />
Dispatched repository mapped in ~0.6 seconds</p></blockquote>

<p>So large or small data sets, there is still a massive performance gain by invoking the call on the STA thread before doing the COM interop work. Here is the code to do that (In production more error handling is probably needed):</p>

<pre><code>public IList&lt;IOutlookFacebookEvent&gt; GetEvents()
{
    var getEvents = ((Func&lt;IList&lt;IOutlookFacebookEvent&gt;&gt;)(() =&gt; _outlookEventRepository.GetEvents()));

    return (IList&lt;IOutlookFacebookEvent&gt;)_outlookStaDispatcher.Invoke(getEvents);
}
</code></pre>

<h1>Wrapping Up</h1>


<p>So we have used quite a few patterns together to achieve a very solid repository that performs well from any thread you call it from. We used the Repository Pattern, the Adapter Pattern and the Decorator Pattern to make it all work.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[IoC, Dependency Injection and VSTO]]></title>
    <link href="http://JakeGinnivan.github.io/ioc-dependencyinjection-vsto/"/>
    <updated>2010-04-23T00:00:00+01:00</updated>
    <id>http://JakeGinnivan.github.io/ioc-dependencyinjection-vsto</id>
    <content type="html"><![CDATA[<p>A really common problem I see with VSTO is getting access to dependencies. Because the framework builds your ribbons and the main point of interaction is in the Load event, developers resort to putting dependencies in their ThisAddin.cs class, then access them through Globals.ThisAddin.MyDependency.</p>

<p>This is bad..</p>

<p>Unfortunately out of the box this is really hard to get around, in this post I will present a few options and a few helper classes that will be included in Outlook.Utility very soon.</p>

<p>I try to use IoC and DI as much as I can inside Outlook add-ins, in some places this is really hard, so I fall back to a ServiceLocator.</p>

<!-- more -->


<h1>Why IoC <strong>and</strong> ServiceLocator</h1>


<p>If you are not sure about what IoC, DI or a ServiceLocator is I suggest you do some reading, understanding these concepts (even if you do not use them) will make you a better developer. Start at <a href="http://martinfowler.com/articles/injection.html">http://martinfowler.com/articles/injection.html</a>.</p>

<p>The main problem is if you create a Ribbon with designer support, VSTO constructs the class for you, then you add your code in the Ribbon_Load event handler that is setup for you. Many parts of VSTO also suffer from this issue. So we can use the service locator in these area’s.</p>

<p>Because I use both a service locator and a IoC container I will use the Common Service Locator to wrap my IoC container so we only have to register our components once with our IoC container, and the ServiceLocator will use our container to resolve the dependencies, and does not tie our code to a specific container.</p>

<h1>What you need</h1>


<ul>
<li>A IoC container (I will be using <a href="http://code.google.com/p/autofac/">Autofac</a>)</li>
<li><a href="http://commonservicelocator.codeplex.com/">Common Service Locator</a></li>
<li>Common Service Locator adapter for your IoC container. Autofac has one in the <a href="http://code.google.com/p/autofac/downloads/list">contrib project</a>.</li>
</ul>


<h1>Registration</h1>


<p>There are two components I see are essential to register in your IoC container, I have found a lot of my Services/Repositories will use them. Application.Session (NameSpace interface) is your current outlook session, you need the session to create or search for Items. And the Dispatcher for the Outlook STA thread.</p>

<h1>Outlook runs in a Single Threaded Apartment</h1>


<p>Outlook runs in what is called a <a href="http://msdn.microsoft.com/en-us/library/ms680112(VS.85).aspx">Single Threaded Apartment (STA)</a>, which essentially means Outlook runs on a single thread, all calls to the Outlook Interop library will be marshalled to the STA if you make the call on a background thread, this is expensive, if you are doing heavy interaction with Outlook, don’t do it from a background thread, BUT still make web service and other long calls or heavy work in .NET then do it on a background thread.</p>

<h1>Usage</h1>


<p>I will cover more advanced uses of IoC and how to get it working with Ribbons and other area’s later in this series. For now if you understand IoC you want to use it to register all your services and the .Core project should not have to use the ServiceLocator.</p>

<p>Then in your Ribbon_Load event handler you can simply go:</p>

<pre><code>var dialogService = ServiceLocator.Current.GetInstance&lt;IDialogService&gt;();
</code></pre>

<p>To resolve your dependencies.</p>

<p>Next I will be talking about how to get data out of Outlook safely (no leaking COM objects) by using the Repository pattern.</p>
]]></content>
  </entry>
  
</feed>
